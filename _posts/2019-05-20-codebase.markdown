---
layout: post
title:  "PS codebase"
date:   2019-5-20 09:00:05 +0800
categories: problem_solving
use_math: true
tags: problem_solving need_review coding
---

### LCA - Binary Lifting
* 구간트리와 비슷한 원리 (또는 뭐, 이진법...)
* 공통부모가 같지 않으면 lift up!
* 2^level을 까먹지 말자.
* \\(\text\{dp[nd][lvl] \}\\) : 노드 nd의 \\(2^\text\{lvl\}\\) 번째 조상. 이 값은 노드 nd의 \\(2^\text\{lvl-1\}\\)번째 조상이 있다는 가정하에, 그 조상의 \\(2^\text\{lvl-1\}\\)번째 조상으로 업데이트 할 수 있음

```cpp
for (int lvl = 1; lvl < 20; lvl++) {
    for (int n = 1; n <= N; n++) {
        if (dp[n][lvl - 1] != -1) {
            dp[n][lvl] = dp[dp[n][lvl - 1]][lvl - 1];
        }
    }
}
int l, r;
for (int m = 0; m < M; m++) {
    cin >> l >> r;
    if (lvls[l] < lvls[r])swap(l, r);
    for (int lvl = 19; lvl >= 0; lvl--) {
        if (dp[l][lvl] != -1 && lvls[l] - lvls[r] >= pow(2, lvl))l = dp[l][lvl];
    }
    if (l == r) {
        cout << l << endl;
        continue;
    }
    for (int lvl = 19; lvl >= 0; lvl--) {
        if (dp[l][lvl] != dp[r][lvl])l = dp[l][lvl], r = dp[r][lvl];
    }
    cout << dp[l][0] << endl;
}
```
### Sparse Table
```cpp
for (int lvl = 1; lvl < lgN; lvl++) {
    for (int n = 0; n < max_N; n++) {
        if (n + pw2[lvl-1] >= max_N)
            continue; // 이 부분이 속도개선에 중요. 거의 4배차이쯤 나는듯
        dp[n][lvl] = min(dp[n][lvl - 1], dp[n + pw2[lvl - 1]][lvl - 1]);
    }
}
```
lg2, pw2계산, 0번 레벨 초기화는 알아서 하시고...


### Heap
* 시작은 1
* heapsize는 항상 valid한 마지막 item을 가르키게 (0일시 empty)

```cpp
const int max_heap = 501;
pair<int, int> heap[max_heap];
int heapSize=0;

void pop(){
    if (heapSize == 0)return;
    int nd = 1;
    heap[nd] = heap[heapSize--];
    while (nd <= heapSize){
        int l = -1, r = -1;
        if (nd * 2 <= heapSize)
            l = nd * 2;
        if (nd * 2 + 1 <= heapSize)
            r = nd * 2 + 1;

        int minI = -1;
        if (l != -1 and r != -1) minI = heap[l] > heap[r] ? r : l;
        else if (l == -1) minI = r;
        else if (r == -1) minI = l;

        if(minI != -1 && heap[minI] < heap[nd]){
            swap(heap[minI], heap[nd]);
            nd = minI;
        }else break;
    }
}

void push(pair<int, int> val){
    heap[++heapSize] = val;
    int nd = heapSize;
    while(nd != 1){
        int p = nd / 2;
        if(heap[p] > heap[nd]){
            swap(heap[p], heap[nd]);
            nd = p;
        }else break;
    }
}
```

### Segtree
```c++
int ary[MAXN * 4];

int update(int ind, int val, int node, int from, int to){
	if (ind < from || to < ind)return ary[node];
	if (from == to)return ary[node] = val;
	int mid = (from + to) / 2;
	return ary[node] = update(ind, val, node * 2, from, mid) + update(ind, val, node * 2 + 1, mid+1, to);
}

int squery(int x, int y, int node, int from, int to){
	if (x > y)return 0;
	if (y < from || to < x)return 0;
	if (x <= from && to <= y)return ary[node];
	int mid = (from + to) / 2;
	return squery(x, y, node * 2, from, mid) + squery(x, y, node * 2 + 1, mid+1, to);
}
```

### Union-and-find
* rank가 낮은 트리를 높은 트리 밑에 집어넣어야 1자형이 안생긴다

```cpp
int find(int u){
    if(u == p[u])return u;
    return p[u] = find(p[u]);
}

void merge(int u, int v){
    u = find(u);
    v = find(v);
    if (u == v)return;
    if (rank[u] > rank[v])swap(u, v);
    p[u] = v;
    if(r[u] == r[v])r[v]++;
}
```

### Quicksort
* Random_shuffle 한 번 돌리고 시작하거나 (expert에선 못쓰지 않나) pivot을 랜덤으로 잡아줄 것
* merge sort가 나은 것 같은디...? 보통 sorting이 가능한데 메모리가 부족한 경우는 없을 테니까?..
* 항상 smInd=-1 로 잡네 ㅡㅡ;

```cpp
void qsort(vector<pair<int, int>>& ary, int fr, int to){
    if(fr >= to)return;
    int piv = to, smInd = fr-1;
    for(int ind = fr; ind < to; ind++){
        if(ary[ind] < ary[piv]){
            smInd++;
            swap(ary[ind], ary[smInd]);
        }
    }
    swap(ary[smInd+1], ary[piv]);
    qsort(ary, fr, smInd);
    qsort(ary, smInd+2, to);
}
```

### Mergesort
N=1일때 다음 null처리 깜빡하지 말자 (linked list sorting하는 경우)
```cpp
ListNode* mergesort(ListNode* head, int N){
    if (N == 1){
        head->next = NULL; //이부분 중요
        return head;
    }
    int mid = (int)(N/2);
    ListNode* r = head;
    for(int i = 0; i<mid; i++)r = r->next;
    head = mergesort(head, mid);
    r = mergesort(r, N-mid);
    ListNode* ret = NULL;
    ListNode* pnt = NULL;
    if(head->val < r->val){
        ret = head;
        head = head->next;
    }else{
        ret = r;
        r = r->next;
    }
    pnt = ret;
    while(head != NULL || r != NULL){
        if(head != NULL && r != NULL){
            if(head->val < r->val){
                pnt->next = head;
                head = head->next;
            }else{
                pnt->next = r;
                r = r->next;
            }
        }else if(head != NULL){
            pnt->next = head;
            head = head->next;
        }else{
            pnt->next = r;
            r = r->next;
        }
        pnt = pnt->next;
    }
    return ret;
}

```


### Dijkstra

### Bellman-ford

### Edmond-Karp

### Dinic