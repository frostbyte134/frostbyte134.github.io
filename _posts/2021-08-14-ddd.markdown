---
layout: post
title:  "Architecture patterns with Python (+DDD)"
date:   2021-08-14 08:00:05 +0800
categories: coding
use_math: true
tags: coding
---

> Architecture Patterns with Python, Percival, Harry; Gregory, Bob. O'Reilly Media. Kindle Edition. 

[https://github.com/cosmicpython/book](https://github.com/cosmicpython/book)

### Intro
- Encapsulation
  - simplifying behavior AND hiding data
  - in DDD, we use former def mainly
  - __Encapsulating behavior by using abstractions__ is a powerful tool for making code more expressive, more testable, and easier to maintain (by avoiding Big Ball of Yarn)
  - OOP languages : abstract base class, Python - duck typing is often enough
- `Layered architecture`: Presentation layer (UI) -> Business logic (app) -> Database layer
  - common approach to structuring a system that has a UI, some logic, and a db.
- `DIP`: Dependency inversion principle (D in SOLID?)
  1. High level modules should not depend on low level modules. Both should depend on abstractions
  2. Abstractions should not depend on details. Instead, details should depend on abstractions.

- `High-level modlues`: functions, classes, packages that deal with our real-world problems
- `low-level modules`: HTTP, uWSGI, nginx, ... ones that business owners never cares
- `Depends on`: does not mean specific, technical things (imports, calls). Rather it simply means that one __knwos about or needs__ the other module.

> So the first part of DIP says that our business code should not depend on techincal details; instead, both should use abstractions

- `Abstraction`: simplified interfaces that encapsulate behavior
  - why depend on abstraction? -> we want to change each items seperately


3 layered architecture
- Presentation layer
- Business logic
- Database layer


### Chap 1 Domain modeling
- how we can model business processes with code, in a way thats highly compatible with TDD

- __business logic layer = domain model__
  - `domain`: (a fancy way  of saying) the problem we want to solve
  - `model`: map of process that captures a useful property
  - `domain model`: mental map that business owners have of their business
    - 비즈니스 오너들의 멘탈 모델을 그대로 구현하는 것이 좋다고 함 (이미 문제를 잘 표한하고 있는 사람들이므로)
    - When we hear our business stakeholders use unfamiliar words, or using tems in a specific way, we should listen to understand the deeper meaning and encode their hard-won experience into our service
- DDD says that the most important thing about software is that it provides a useful model of a problem
  - 가장 중요: 딴 것들 (especially tech details)이 도메인 모델에 의존적이여야 함
- Explore the Domain Language
  - domain expert들이 사용하는 언어를 도입하는 게 좋음. 이미 문제에 대한 abstraction이 충분이 잘 돼 있음.

#### Domain language
- Product ID = SKU
- Customer places orders
  - Order (pk = order reference)
    - can have multiple products (SKUs) 
    - composed of `order lines` (= an unique SKU and quantity)
- batch = 도매상으로의 주문 (pk = batch reference, a SKU, quantity, ETA (도착기간))
- __we need to allocate order lines to batches__ 
- `allocation` : concept of linking an OrderLine to a Batch
  - we store allocation as a collection on our batch object (as as set)

#### 코드
- Orderline 클래스는 `@dataclass(frozen=True)`로 잠궈놓음
  - `value object` : definde by its attributes. 보통 임뮤터블하게 해 놓음
  - 해쉬 자동으로 생성해 주는 듯
- `entity` : identity를 가지고, 식별되는 것 (with PK)
  - "We use the term entity to describe a domain object that has long-lived identity"
  - `__eq__, __hash__` 구현하면 편하나 해시 구현 시 조심해야 함
- `domain service function`: entity나 value object가 아닌 것 (ex - allication of order line to batch)
- exceptions can be uised to express domain concepts too

<img src="{{ site.url }}/images/coding/python/../../../../../images/coding/python/ddd_1.gif" class="center" style="width:300px"/>
- <a href="https://github.com/Dev-Nebe/architecture-patterns-with-python/blob/master/src/allocation/domain/model.py" target="_blank">코드</a>를 보면, `allocate()`는 실제로 batch의 동작에 의존함. order_line도 파라미터로 받긴 하는데 얘한테 의존하는 건 없음 (order_line의 동작이 바껴도 allocate에 영향 X)


### Chap 2 Repository pattern
- ... to use the dependency inversion principle as a way of decoupling our core logic from infrastructural concerns
- ... but we want our domain model to have no dependencies whatsoever. We don't want infra concerns bleeding over into our domain model and slowing our unit tests or our ability to make changes.
  - model inside, dependencies floowing inward to it; `onion architecture`

`Repository pattern`: a simplifying abstraction over data storage, allowing us to decouple our model layer from the data layer.
- we want our domain model to have __no dependency whatsoever__
  - we'll think of our model as being on the inside, and dependencies flowing inward to it (`onion architecture`)

`@abc.abstractmethod` is one of the only things that makes ABCs actually work in Python

#### ORM
- normal ORM way : model depend on ORM (model is defined with ORM)
  - pros of ORM: `persistence ignorance` (do not need to care how the date is stored in persistent manner)
- __INVERTING THE DEPENDENCY__: ORM depends on Model
  - define schema explicitly, and to define an explicit mapper for the ORM (`classical mapping` in SQLAlchemy)
  - the ORM imports (or "depends" or "knows about") the domain model, and not the way around


#### The Repository Pattern
`Dependency Injection` : Create ABCRepository class
  - can easily introduce new ORM
  - fake ORM (not the "mock")
  - no need to use ABC class. duck-typing is often sufficient in real fields (too easy to ignore them)

Trade-off
- introducing additional layer of abstraction
  - make easy to make a change (fundamental) to they way we store things
  - easy to fake unit test

#### Port and Adapters
- port = interface (abstraction)
- adapter = implementation (instance) of port

### Chap 3 On copuling and abstractions

> A key theme in this book ... is that we can use simple abstractions to hide messy details.

In a large-scale system, we become constained by the decisions made elsewhere in the system (coupling)
- __locally__, coupling is a proof that your module is related
- __globally__, coupling is a nuisance (increase the cost of code change, exponentially)
   - we can reduce the degree of coupling, by abstracting away the details

#### Abstracting states aids testability
make stateful component explicit and plug-and-playable

- 폴더 비교 및 sync 기능 구현
- 그냥 짜면 os.listdir / hashlib (체크) / shutils (복사) 범벅이 됨. 근데 이건 사실 `core functionality`가 아님 (tightly coupled with file I/O)
  - core는 파일을 비교하고 적절한 연산을 해 주기만 하면 됨. 이 부분을 구현하고, IO관련 부분은 주입하면됨 (Dependency Injection!)
  - 이 core는 external state에 의존적이면 안됨. 들어온 입력에 대해 항상 일정해야 함.
  - core = `bueiness logic`

> We're going to seperate `what` we want do to from `how` we do it. 띵언 ㄷㄷ

이러면 테스트 시 DI를 사용해 간편하게 테스트를 만들 수 있음 (aids testability)
 - `edge to edge testing`
 - DI는 굳이 ABC로 짤 필요 없음. duck typing에만 의존해도 됨.
 - file mocking (=patching out dependency) 도 나쁘지 않지만, 결국 이 과정을 통해 stateful한 부분을 core logic과 분리하는 것 자체가 좋음.

> We view TDD as a design practice first and a testing practice second (2차 띵언 ㄷㄷ)

 - The tests act as a record of our design choices, and serve to explain the system to us when we return to the code after a long absence
 - Tests that use too many mocks get overwhelmed with setup code that hides the story we care

In summary
- We can make our systems easier to test and maintain by simplifying the interface between our business logic and messy I/O. Finding the right abstraction is tricky, but here are a few heuristics and questions to ask yourself.
  - Can i choose a familiar Phtyhon data structure to represent the state of the messy system and then try to imagine a single function that can return the state?
  - Where can I draw a line between my systems?
  - What is a sensible way of dividing things into components with different responsibilities?
  - What are dependencies, and what is the core business logic?


### Chap 4 Service Layer

> we discuss the difference between orchestration logic, business logic, and interfacing code, and we introduct the `Service Layer` pattern to take care of orchestrating out workflows and defining the use cases of our systems

orchestration (디비에서 값 뺴오고, 입출력 검사하고, 에러 처리하고, 결과 커밋 등)을 api구현에서 분리해서 새 레이어로 (`orchestration layer` = `service layer`)

