---
layout: post
title:  "Python asyncio"
date:   2020-03-01 09:00:05 +0800
categories: coding
use_math: true
tags: coding python
---

### Python 3.8 asyncio document
<a href="https://docs.python.org/3/library/asyncio.html" target="_blank">https://docs.python.org/3/library/asyncio.html</a>

* asyncio is a library to write concurrent code using the `async/await` syntax.  
* asyncio is often a perfect fit for __IO-bound__(GIL!) and high-level structured network code.
* `asyncio.run(coroutine)`: 단일 진입점이 되는 메인 코루틴을 실행시키는 데 좋음
* await 만으론 concurrent execution이 안됨. `async def`로 선언된 coroutine을 `task = create_task(coro)`함수로 task로 만들어 줘야 concurrent execution이 됨
  * create_task로 만들어진 task객체는 concurrent 실행 (await) 될 수 있고, .cancel()로 취소할 수도 있음



__Important__ In this documentation the term “coroutine” can be used for two closely related concepts:
* a `coroutine function`: an async def function;
* a `coroutine object`: an object returned by calling a coroutine function.

three main types of awaitable objects: `coroutines`, `Tasks`, and `Futures`.
* Python coroutines are awaitables and therefore can be awaited from other coroutines
* Tasks are used to schedule coroutines concurrently.


A `Future` is a special low-level awaitable object that represents an eventual result of an asynchronous operation.
* A good example of a low-level function that returns a Future object is `loop.run_in_executor()`.


running an asyncio program: `asyncio.run(coro)`  
creating task: `asyncio.create_task(coro)`
Sleeping: `coroutine asyncio.sleep(coro)`  
Running Tasks Concurrently: `awaitable asyncio.gather(coro)`

### Coroutines and Tasks

> Subroutines are special cases of coroutines (Knuth)
  Any subroutine can be translated to a coroutine which does not call yield ("Epigrams on programming")

#### Coroutine vs thread
> <a href="https://en.wikipedia.org/wiki/Coroutine" target="_blank">Coroutines are very similar to threads.</a> However, coroutines are cooperatively multitasked, whereas threads are typically preemptively multitasked. This means that coroutines provide <a href="https://stackoverflow.com/questions/1050222/what-is-the-difference-between-concurrency-and-parallelism" target="_blank">concurrency but not parallelism.</a> The advantages of coroutines over threads are that they may be used in a hard-realtime context (switching between coroutines need not involve any system calls or any blocking calls whatsoever), there is no need for synchronisation primitives such as mutexes, semaphores, etc. in order to guard critical sections, and there is no need for support from the operating system.  
It is possible to implement coroutines using preemptively-scheduled threads, in a way that will be transparent to the calling code, but some of the advantages (particularly the suitability for hard-realtime operation and relative cheapness of switching between them) will be lost.


#### Coroutine vs generator
> <a href="https://en.wikipedia.org/wiki/Coroutine#Comparison_with_generators" target="_blank">Wikipedia</a> - Generators, also known as semicoroutines,[5] are a subset of coroutines. Specifically, while both can yield multiple times, suspending their execution and allowing re-entry at multiple entry points, they differ in coroutines' ability to control where execution continues immediately after they yield, while generators cannot, instead transferring control back to the generator's caller.

* `sub routine`: supports `main routine`. often implemented as functions without return value. 별도의 메모리공간에 sub-routine이 존재. return으로 종료. 종료 후 별도의 context (stack, register vals)를 저장하지 않음
* `coroutine`
  * 별도의 메모리공간에 았는 것은 동일 
  * `yield`를 통해 잠시 실행 권한을 반환했다가, 나중에 다시 그 위치에서 실행가능
  * 여러 진입점 보유가능 (?) - 메인루틴에 종속적이지 않음 

<a href="https://blueshw.github.io/2016/01/25/python-co-routine-vs-sub-routine/" target="_blank">https://blueshw.github.io/2016/01/25/python-co-routine-vs-sub-routine/</a>
> `next(coroutine)`은 coroutine 함수의 첫번째 yield 까지 호출한다음 대기합니다 ... iteration 이 가능한곳까지 next 함수가 수행된 뒤에는 StopIteration 에러가 발생하게 됩니다.  
  만약 yield 문이 대입연산의 우변에 있다면 해당 코루틴 객체에 send(value)를 호출해 주어야 합니다. somevar = yield valA 에 멈춰있는 상태에서 valA에 값이 전달되어야 하는데 아무런 값도 들어오지 않는다면 에러가 발생하게 됩니다. (무슨 에러?) 즉, yield 를 통해서 메인루틴과 서브루틴간에 서로 값이 이동하면서 특정 로직을 수행하게 되는 것입니다.


<a href="https://docs.python.org/3/library/asyncio-task.html" target="_blank">python 3.8.3 documentation of coroutine</a>


* <a href="https://tech.ssut.me/python-3-play-with-asyncio/" target="_blank">https://tech.ssut.me/python-3-play-with-asyncio/</a> - old
* <a href="https://nachwon.github.io/asyncio-and-threading/" target="_blank">https://nachwon.github.io/asyncio-and-threading/</a>  
> 코루틴은 항상 반드시 하나의 코루틴만 실행되기 때문에 (이벤트 루프 하나에서), 여러 쓰레드들을 사용할 때처럼 락을 관리할 필요가 없다. 다른 코루틴으로 제어권을 넘겨주려면 await 문을 사용하여 언제든지 넘겨줄 수 있다. 그렇기 때문에 코루틴은 안전하게 취소할 수 있다. 코루틴이 멈춰있던 await 문에서 CancelledError 를 처리해서 마무리하면 된다.
* https://sjquant.tistory.com/14  
  1. 이벤트 루프(Event Loop)
이벤트 루프는 작업들을 루프(반복문)를 돌면서 하나씩 실행시키는 역할을 합니다. 이때, 만약 실행된 작업이 특정한 데이터를 요청하고 응답을 기다려야 한다면, 이 작업은 다시 이벤트 루프에 통제권을 넘겨줍니다. 통제권을 받은 이벤트 루프는 다음 작업을 실행하게 됩니다. 그리고 응답을 받은 순서대로 멈췄던 부분부터 다시 통제권을 가지고 작업을 마무리합니다.
  1. 코루틴(Coroutine)
이때, 이러한 작업은 파이썬에서 코루틴(Coroutine)으로 이루어져 있습니다. 코루틴은 응답이 지연되는 부분에서 이벤트 루프에 통제권을 줄 수 있으며, 응답이 완료되었을 때 멈추었던 부분부터 기존의 상태를 유지한 채 남은 작업을 완료할 수 있는 함수를 의미합니다. 파이썬에서 코루틴이 아닌 일반적인 함수는 서브루틴(Subroutine)이라고 합니다.
* https://hamait.tistory.com/833

실화인가 ㄷㄷ
e
`async def` 함수명

코루틴 실행: loop.run_until_complete(supervisor()), 


### Coroutines
* <a href="https://hamait.tistory.com/830" target="_blank">https://hamait.tistory.com/830</a>
* <a href="https://docs.python.org/ko/3/library/asyncio-task.html" target="_blank">https://docs.python.org/ko/3/library/asyncio-task.html</a>
* https://sjquant.tistory.com/14
    - 이벤트 루프


### AsyncIO


### How to benefit from asyncIO?
* IO bottleneck handling?


### 어웨이터블
우리는 객체가 await 표현식에서 사용될 수 있을 때 어웨이터블 객체라고 말합니다. 많은 asyncio API는 어웨이터블을 받아들이도록 설계되었습니다.

어웨이터블 객체에는 세 가지 주요 유형이 있습니다: 코루틴, 태스크 및 퓨처.


### Future
```
from concurrent.futures import ThreadPoolExecutor
from time import sleep
 
def return_after_5_secs(message):
    sleep(5)
    return message
 
pool = ThreadPoolExecutor(3)
 
future = pool.submit(return_after_5_secs, ("hello"))
print(future.done())
sleep(5)
print(future.done())
print(future.result())

```
출처: https://hamait.tistory.com/828 [HAMA 블로그]
