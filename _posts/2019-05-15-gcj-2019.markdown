---
layout: post
title:  "GCJ 2019"
date:   2019-5-15 09:00:05 +0800
categories: problem_solving
use_math: true
tags: problem_solving need_review
---

### Alien Thyme

문제
1. 문자열을 "뒤에서부터" 일치시켰을 때, 일치하는 substring들이 많을 수도 있고 없을 수도 있다.
2. 문자열들을 pair로 짝지어서, unique한 패턴 1개당 문자열 2개만 지울 수 있다고 할 시
3. 가장 많이 지울 수 있는 문자열들의 갯수는?

풀이시도
1. 2개씩 짝지어서 버리면 되니까, 문자열을 char를 노드로 하는 그래프 (뒤에서부터)로 만들고, 일치하는 부분까지는 count를 샌 다음에, dfs로 깊은 곳에서부터 2개씩 없애나가면 될 거라고 생각했음. dfs의 반환값으론 지금까지 자식에서 없앤 수 만큼 반환하면, 현재 count에서 반환값을 뺴고 생각하면 되니까.
2. 그래프를 C++로 만들려고 시도했는데, 각 노드별로 26개의 자기자신 (다음) 배열을 만들려고 했는데 이게 구현상 안되는 듯. 당연한가..
3. 결국 해답은
   1. map에 뒤에서부터의 각 substr의 count를 저장하고 (원래 그래프로 하려던 것)
   2. map을 C++ functor를 써서 문자열 갯수가 많은 것이 앞으로 오게 (=dfs로 깊은 것 부터) 정렬하고, 2개를 없앨 수 있으면 자기자신 substr들에서 2개씩 빼 주면 됨. 
   3. struct를 이용한 functor과 map 정렬에 대해 좀 배운듯. 근데 closure를 되게 불편하게 쓰네..

### Pylons

문제를 최적화할 수 있는 방법이 보이지 않았고, 큰 수에 대해서는 가짓수가 엄청 많아서 비교적 금방 풀릴 것 같았음.  
앞으로 이런 상황이면 `random_shuffle`을 사용해 봅시다. next move를 다 vector에 저장하고, 셔플 후 완탐 ㄱㄱ