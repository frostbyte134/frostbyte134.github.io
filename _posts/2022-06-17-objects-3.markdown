---
layout: post
title:  "Objects - 코드로 이해하는 객체지향 설계 Chap10, 11, 12"
date:   2022-06-12 08:00:05 +0800
categories: coding
use_math: true
tags: coding
---


### Chap 10

객채지향의 장점 중 하나 - 코드 재사용  
객체지향에서는 __코드를 재사용하기 위해 새로운 코드를 추가__
- `상속`: 클래스를 재사용하기 위해 새로운 클래스를 추가
- `합성`: 새 크래스 객체 안에 기존 클래스의 인스턴스 포함

`DRY`원칙
- Dont Repeat Yourself
- 코드 중복 여부 = 변경 시 같이 변경되는가. 코드 모양이 유사하다는 것은 중복의 징후일 뿐임
- 중복 코드는 변경을 방해한다. 이것이 중복코드를 제거해야하는 가장 큰 이유다
- 중복 코드는 (서로) 다르게 변경하기도 쉬움 -> 로직이 요구사항과 틀리게 될 가능성이 높음
- 중복 코드를 제거하지 않고 코드를 수정할 수 있는 유일한 방법은 새로운 중복코드를 추가하는 것 뿐이다

#### 중복과 변경
중복제거의 방법 중 하나 - 클래스를 하나로 합치고, 내부에서 조건문으로 판단
- OOP는 조건문 대신 타입으로 런타임에 분기를 탈 수 있음 (`상속`)

상속의 문제
- 상속 하이어라키 상에서 (=부모 클래스들에서) 개발자가 만든 가정을 다 이해해야 함
- 결합도가 높아짐 -> 이 강한 결합도가 코드를 수정하기 어렵게 만든다
- 자식 클래스가 super참조를 이용해 부모클래스의 메서드를 호출할 경우, 결합도가 너무 큰 것임 - 제거해야 함

#### 취약한 기반 클래스 문제
상속은 자식과 부모 클래스 간의 결합도를 높인다
- 핵심적인 기반 클래스에 대한 단순변경 가정
  - 모든 기반클래스 + 파생클래스의 메서드들을 다 테스트해야 함 
- __취약한 기반 클래스 문제는 상속이라는 문맥 안에서 결합도가 초래하는 문제점을 가리키는 용어다__. 상속 관계를 추가할수록 전체시스템의 결합도가 높아진다는 사실을 알고 있어야 한다.
- 상속은 자식클래스를 점진적으로 추가해서 기능을 확장하는데는 용이하지만, 높은 결합도로 인해 부모 클래스를 개선하는 것은 어렵게 만든다
- 상속은 __자식클래스가 부모클래스의 구현 세부사항에 의존하도록 만들기 때문에 캡슐화를 약화시킨다__
- 캡슐화 - 구현 세부사항을 인터페이스 뒤로 숨겨서, 변경의 파급범위를 제어
  - 상속은 캡슐화를 쉽개 깰 수 있음 (부모-자식 간)

상속받은 부모 클래스의 메서드가 자식클래스의 로직을 깨트릴 수 있다
- 불필요한 인터페이스까지 다 상속받게 됨. 실제 상속관계 (강한 결합도)로 완벽하게 표현할 수 있는 관계는 많지 않음

메서드 오버라이딩할 경우, 부모클래스가 자신의 메서드를 사용하는 방법에 자식클래스가 결합될 수 있다
- Joshua Bloch said..
  - 오버라이딩 가능한 메서드를 호출하는 모든 상황에 대해 문서화해야 함. but 잘된 API문서는 메서드의 what만을 기술하고 how는 기술하면 안됨 - 상속이 캡슐화를 위반함으로서 생기는 문제. __서브클래스가 안전하게금 클래스를 문서화하려면, (어쩔 수 없이) 클래스의 상세 구현 내역을 기술해야 한다__
  - 상속을 위해 설계된 슈퍼클래스가 아닐 경우, 결합도가 너무 강해짐. 서브클래스를 변경하지 않았더라도 슈퍼클래스의 변경에 의해 서브클래스가 꺠질 수 있음.


#### '위로 올리기' 전략
1. 공통메서드 추출
2. 부모-자식 관계 말고, 자식을 부모로 올린 뒤 둘 다 공통 추상클래스에 의존하개
  - 중복코드는 추상클래스에, 추출한 메서드만 따로 구현


#### 차이에 의한 프로그래밍
상속은 강력한 도구임
- 익숙한 개념을 이용해 새로운 개념을 쉽고 빠르게 추가가능
- 기존 코드와 다른 부분만 추가해서 기능 확장 = `차이에 의한 프로그래밍`
- 상속을 잘 이용하면 앱의 점진적인 정의 (incremental definition)가 가능해짐
- but 지나친 결합도 때문에, 많은 경우 우아한 해결법이 아님 -> 합성
