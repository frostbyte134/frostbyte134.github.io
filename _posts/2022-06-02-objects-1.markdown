---
layout: post
title:  "Objects - 코드로 이해하는 객체지향 설계 Chap4, 5, 6"
date:   2022-06-02 08:00:05 +0800
categories: coding
use_math: true
tags: coding
---

블로그 어카지 ㄷㄷ AWS로 옮기고 싶긴 한데 latex이 좀....

훌륭한 설계란 합리적인 비용 안에서 수용가능한 구조를 만드는 것 (= 응집도가 높고 느슨하게 결합된 구조)

### Chap 4
- 협력: 앱 기능구현을 위해, 메시지를 주고받는 객체들 간 상호작용
- 책임: 협력을 위해 객체가 수행하는 행동
- 역할: 대체가능한 책임의 집합 (약간 인터페이스 느낌)

결국 책임이 제일 conerstone임 (맨 밑에 있음. 책임주도설계란 말이 있는 이유)

> 객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다 [Evers09]

해설
1. 책임이 젤 중요
2. 책임을 잘 할당하면 결합도/응집도도 잘 풀린다
3. 책임에 초점을 둔다 = 객체의 상태보단 행동에 초점을 둔다

#### 데이터 중심 vs 책임 중심
시스템을 분할하는 2가지 방법 = 상태중심 / 책임중심 분할
1. 상태중심 분할 - 상태(데이터)는 구현에 따라 바뀜 (자주 변함)
  - 데이터(멤버변수)부터 고려 -> 이 후 협력이 완성된 구조를 참고 -> 이미 완성된 데이터에 대한 지식 (=구현)이 인터페이스에 드러나게 됨
2. 책임중심 분할 - 책임은 인터페이스에 속함 - 상대적으로 덜 변함

캡슐화란 변경가능성이 높은 부분을 내부로 숨기는 것
 - 데이터 중심으로 설계하고 getter, setter를 자동생성하는건 캡슐화에 전혀 (!) 도움이 안됨
 - `추측에 의한 설계`: __책임중심으로 설계하지 않고 데이터중심으로 설계했기 떄문에, 어떤 협력 컨텍스트에서 객체가 쓰일 지 감이 안잡힘 -> 항상 쓸 수 있게 게터, 세터 추가__
 - 인터페이스를 변경하지 않고 내부 구현만 변경해도, 관련된 getter, setter를 다 변경해야 함
 - 이 객체를 갖다쓰는 쪽에서는, 사실상 내부 구조(상태)를 다 아는 것 (캡슐화 X) -> 결합도 up
 - 객체가 자기 자신에 대해 책임지게 함으로서 캡슐화를 높일 수 있음 (외부에서 내부 로직을 다 알고 조종하면, 해당 객체의 클라이언트가 많아질 때 관리포인트가 늘어남)

bad examples - 멤버변수별로 getter/setter가 있는 것 외에도 구현 노출 (=캡슐화 X)인 경우는 많음
- 함수 시그니처의 파라미터 타입으로 내부 변수 타입 노출
- 함수 종류 (`calcAmountDiscountedFee`, `calcPercentDiscountedFee`, `calcNoneDiscountedFee`)로 할인 종류 노출 (할인 종류별로 메소드를 만들지 말고, 내부 상태로 숨겨서 처리할 수도 있을 듯)
- `정리하면 캡슐화란 변하는 어떤 것이든 감추는 것이다`

유지보수성이란 두려움 없이 코드를 변경할 수 있는 능력

#### 응집도 vs 결합도
응집도 (`cohesion`)
- 높은 응집도
  - 모듈의 요소들이 하나의 목적을 위해 협력
  - 변경이 발생할 떄 모듈 하나에서 해당 모듈 전체가 수정 - 일부는 수정되지 않으면 응집도가 낮다고 볼 수 있는 듯? (=관련없음?)
- 낮은 응집도
  - 서로 다른 목적을 추구 
  - 변경이 발생할 시 여러 모듈들에서 각자의 일부만 수정

SRP (단일 책임 원칙)
 - 클래스는 단 하나의 변경 이유만 가져야 함
 - 높은 응집도를 위한 것


결합도 (`coupling`)
- 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 척도
- 응집도와 독립적인 개념이 아님

결합도가 높아도 되는 경우 - 변경여지가 작은 퍼블릭 모듈 (자바의 ArrayList)에 대한 결합도

> 올바른 객체지향 설계의 무게중심은 항상 객체의 내부가 아니라 외부에 맞춰져 있어야 한다. 객체가 내부에 어떤 상태를 가지고 그 상태를 어떻게 관리하는지는 부가적인 문제다. 중요한 것은 객체가 다른 객체와 협력하는 방법이다


### Chap 5 책임 할당하기
책임 할당 = 트레이드오프 (동일한 문제를 다양하게 해결가능, 상황/문맥에 따라 트레이드오프가 생김)

2가지 원칙
- 데이터보다 행동(책임)을 먼저 결정하라
- 협력이라는 문맥 안에서 책임을 정의/결정하라
  - 객체 입장에선 책임이 어색해도 협력에 적합하다면 좋은 책임 할당임
  - 클래스를 결정하고 그 클래스의 책임을 찾기 = X
  - 메시지를 결정하고 메시지를 누구에게 전송할지 찾기 = O
  - > 객체를 갖고 있기 때문에 메시지를 보내는 것이 아니다. 메시지를 전송하기 떄문에 객체를 갖게 된 것이다 [Metz12]
  - 메시지를 먼저 결정 - 수신자에 대헤 가정하기 어려움 - 자동적으로 캡슐화 - (높은 응집도 + 낮은 결합도)


책임 주도 설계
- 시스템 책임 (전체 책임) 파악 - 작은 책임으로 분할 (여기서 어느정도 책임/메시지 정의가 됨)
- 작은 책임을 수행가능한 객체/역할을 찾아 책임 할당
  - 도움이 필요하거나 책임이 좀 큰 경우, 나눌 객체를 찾아 책임 할당 + 메시지 정의

#### 책임 할당을 위한 GRASP 패턴
General Responsibility Assignment Software Pattern (Craig Larman)
1. 시작점 = domain concepts
  - 도메인 모델도 구현에서 자유로울수는 없음 - 구현을 염두에 두고 도메인 개념들을 구조화하는 것도 중요
2. `INFORMATION EXPERT` 패턴
  - 책임을 정보 전문가에게 할당
  - 정보 != 데이터(멤버변수). 해당 정보를 제공가능한 다른 객체를 __알고__ 있거나, on the fly로 계산할수도 있음
  - 가장 기본
3. `LOW COUPLING` 패턴, `HIGH COHESION` 패턴 
4. `CREATOR`패턴 - 이미 있는 관계 이용
  - B가 A를 포함/참조
  - B가 A를 기록 / 긴밀하게 사용
  - B가 A를 초기화하는데 필요한 데이터를 갖고 있음 (= B는 A에 대한 정보 전문가)
  - 이 경우 B에게 A객체 생성 책임을 맡기면 좋음 (낮은 결합도로 이어짐)


메시지를 보낼 때, raw type보단 객체를 보내는 게 캡슐화에 좋은 듯?
- 아니 근데 이러면 디펜던시가 또 생기는데.. (147p 별표)
- ex) screening이 movie객체에 `calculateMovieFee(Screening screening)`메시지를 보낼 때, screening객체를 보냄으로서 movie의 구현을 몰라도 되게 설계 -> 캡슐화 (movie의 자율성 보장)
  - 반대로 말하면 이걸 받는 movie쪽에선 screening의 구현을 (인터페이스를 통해서라도) 알 수 있는 거 아닌가? 그나물에 그밥 같은데..

#### SRP와 응집도
- 150p의 DiscountCondition은 변경이유 종류가 다양함 (할인조건 추가, 순번조건 판단 변경, 기간조건 판단 변경) - __응집도가 낮다__
  - 변경 이유에 따라 클래스 분해

설계 개선은 SRP원칙 위배를 찾는걸로 시작하는 게 좋음 (`PROTECTED VARIATIONS` 패턴 = 설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 (인터페이스 뒤로?) 캡슐화하라)  
- __위험징후 예시__
  1. 내부 상태 초기화가 한번에 되지 않고 나뉘어서 됨. 시간순으로 나뉘는 경우도 있고, 조건에 따라 일부 변수에는 값이 안들어오는 경우도 있음
  2. 메서드들이 사용하는 내부 상테에 따라 클러스터링 될 수 있을 때 (약간..포레스트처럼 나뉠 떄)

분리한 것들이 비슷한 인터페이스를 지니게 되면 다형성을 통해 관리하는 것도 좋음
 - 분리된 클래스들이 같은 역할을 다르게 수행하는 경우 (책임은 살짝 다르지만)
 - `POLYMORPHISM` 패턴 (다형성 패턴)
  - 객체의 타입에 따라 변하는 행동이 있다면, 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당
  - 되도록이면 if-else 보다는 다형성으로 분기

마지막에 무비를 분리하는 부분은 좀 맘에 들진 않았음...

구현을 가이드할 수 있도록 도메인 모델을 선택하라 (만들지도 않았는데 구현을 어케 암 ㅋㅋ)


#### 리펙토링 - 긴 메서드

몬스터 메서드 (`monster method`)의 단점
- 이해가 어려움 (어디를 변경해야 할 지 찾기어려움)
- 단일 변경이 미치는 범위가 넓어짐
- 일부만 재사용하기 어려움 - 중복 초래 가능성
- 응집도가 높기 어려움 (아무래도 이상한 게 끼어 있겠지...)

책임 주도 설계에 익숙하지 않으면, 데이터 중심 설게를 하고 리팩토링해도 비슷한 효과를 얻을 수 있다 (....)고 합니다~


### Chap 6 메시지와 인터페이스
앱은 클래스의 집합이 아님. 클래스는 객체를 만드는 도구일 뿐
- 앱은 클래스(객체)로 구성되지만 메시지를 통해 정의됨 (~= 책임)

`클라이언트-서버 모델`
  - 클라이언트: 메시지 전송 객체
  - 서버: 메시지 수신 객체
  - 객체는 협력에 참여하는 동안, 서버/클라이언트 역할을 동시에 수행하는 게 일반적 (큰 책임의 메시지를 받아, 일부는 자기가 수행하고 일부는 다른 객체에 메시지 전송)
  - 객체간 협력을 가능하게 해 주는 (유일한) 매개체 - 메시지

`메시지`
- 객체가 다른 객체와 협력하기 위해 사용하는 comm mechanism
- 오퍼레이션명 / 인자로 구성
- 메시지 전송 = 위에 수신자까지 추가  
  ex) 자바의 멤버함수 호출 `condition.isSatisfied(screening);`: 수신자.오퍼레이션명(인자)


`퍼블릭 인터페이스`
- 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합
- 여기에 포함된 메시지 = `오퍼레이션` (내부 구현은 제외한, 추상적인 개념)
- `메서드`
  - 메시지 수신 시 실제로 실행되는 함수
  - 객체에 수신 타입에 따라 동적으로 실행되는 메서드가 다름 (= 메시지/메서드의 분리, 명확한 구분)
    - '우리는 그저 메시지에 응답가능한 객체가 존재하고, 그 객체가 적절한 메서드를 택해 응답할 것이라도 믿을 수 밖에 없다'
    - 느슨한 결합 - 각자 알아서 할 일 하면 됨 (메시지를 보내는/메서드를 호출하는 객체별로) = 유연하고 확장가능한 코드
- `시그니처`: 오퍼레이션/메서드의 명세

#### 인터페이스아 설계 품질
좋은 인터페이스 = 최소한이며 추상적
- 책임주도설계
- `디미터 법칙` (Law of Demeter)
  - 객체의 내부 구조에 강하게 결합되지 않게 협력해라
  - A.func1().B.func2().  이런거 지양 (내부구조를 아는거니까)
  - 오직 하나의 토트만 사용하라
    - 단, 각 메서드가 잘 캡슐화되고 구현이 노출되지 않고, 특히 동일한 타입을 계속 반환할 시 1문장에 여러 도트도 전혀 문제없음
    - 디미터 법칙은 결합도에 관련된 것이며, 내부구조가 노출되지 않았을 시 문제없음
  - 클래스의 인스턴스 변수, 함수에 인자로 전달된 것, 전역변수 외에 사용 X
  - `부끄럼타는 코드` 작성가능 (불필요한 것 노출 X, 다른 객체 구현에 의존 X)
  - 캡슐화의 다른 표현 (객체는 자율적인 존재다)
  - 객체의 내부구조를 묻는 메시지가 아니라, 수신자에게 무언가를 시키는 메시지가 더 좋은 메시지다 (묻지 말고 시켜라 Tell, Don't ask)

디미터 법칙 위반 = 인터페이스 분리 원칙 (`interface segregation principle`) 위반이기도 함
- 객체의 구현이 퍼블릭 인터페이스를 통해 세어나가기 때문
- 갖다 쓸 때 마다 다른 여러 객체의 내부구현도 알아야 함 = 개어려움

#### 의도를 드러내는 인터페이스

Kent Beck - __메서드가 작업을 어떻게(how) 수행하는지를 반영하는 이름은 안좋다__
- ex - PeriodCondition 클래스의 isSatisfiedByPeriod 메서드, SequenceCondition의 isSatisfiedBySequence 메서드
- 갖다쓰는 클라이언트 입장에서는 조건 체크하는 비슷한 연산인데 객체를 구분해야 함
- 메서드 레벨에서 캡슐화를 위반하기도 함!
- 두 메서드를 isSatisfiedBy로 변경 - 무엇을 (what, intent)하는지를 나타냄 - 다형성 등으로 코드수정없이도 클라이언트의 동작 변경 가능
  - 의도를 드러내는 선택자 패턴 `Intention Revealing Selector`
  - __훈련방법:__ 매우 다른 두번째 구현 상상, 해당 메서드에 동일한 이름을 붙인다고 상상 -> 추상적인 이름을 붙이게 됨 ㅋㅋ
  - 이걸 인터페이스 레벨로 바꿈 - 의도를 드러내는 인터페이스 패턴 (`Intention Revealing Interface`)
- 오퍼레이션의 이름은 협력이라는 문맥을 고려해야 함
  - 클라이언트가 서버에거 뭘 원하는지를 표현해야 한다 (setTicket -> buy, sellTo, hold (서버에 따라))

#### 원칙의 함정 - 결합도와 응집도의 충돌
디미터 법칙 적용 - 캡슐화를 위해 위임 메소드를 (막) 추가하다 보면, 인터페이스에 함수가 많아질 수 있음
- 캡슐화는 되서 결합도는 내려갔지만, SRP위반으로 응집도도 내려감 (작은 변경에도 고쳐야 할 게 많을 수 있음)
- 자료구조라면 디미터 법칙이 적용되지 않음 (당연히 내부를 노출하는 게 편함). 객체에만 디미터 법칙이 적용
- __객체에게 시키는 것이 항상 가능한 것은 아님. 가끔은 물어봐야 함__


#### 명령 - 쿼리 분리 원칙
`command-query seperation` (CQRS)

- `routine`: 어떤 절차를 묶어 호출가능하도록 이름을 부여
  - `procedure`: 루틴의 한 종류. 반환 없음. = `command`
  - `function`: 루틴의 한 종류. 반환값이 있음 = `query`

> 어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안 된다.

따라서 CQRS를 지키기 위해선 다음 두 규칙을 준수해야 한다
1. 객채의 상태를 변경하는 명령은 반환값을 가질 수 없다
2. 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다

`질문이 답변을 수정해서는 안 된다`
- 이러면 사이드이팩트를 일으키는 건 command이지 function이 아니므로, 수학의 함수의 정의와 일치함
- CQRS를 따르는 인터페이스를 Command-Query Interface라고 부름
- 기계 메타포: 명령을 내리면 동작만 함. 결과는 led패널로 따로 확인
- CQRS의 장점
  - 커맨드를 실행하지 않았을 시 쿼리를 멱등적으로 바꿈 (상태변환을 하지 않으므로) = `참조 투명성`을 조건적으로 보장
  - 코드를 이해하기 쉬워짐

컴퓨터와 수학의 함수를 나누는 가장 큰 특징: side effect
- `참조 투명성` (`referential transparency`): 어떤 표현식 e가 있을 때, e가 쓰이는 모든 곳을 e의 값(수식)으로 교체하더라도 결과가 달라지지 않음
- CQRS - 커맨드가 실행되지 않았을 때 참조투명성 보장
- OOP는 객체의 상태변경이라는 사이드 이펙트를 기반으로 하기 떄문에, 참조투명성은 예외에 가깝다

`명령형 프로그래밍` imperative programming : 사이드이펙트를 만드는 명령들을 적절한 순서로 배열. 대부분의 OOP언어는 명령형임. 반 - 함수형

#### referential transparent vs idempotent

<a href="https://medium.com/@_ericelliott/idempotency-and-referential-transparency-are-related-but-different-518a5b810700" target="_blank">link</a>  
Idempotency and referential transparency are related, but different. All referentially transparent functions are idempotent, but the reverse is not true. An idempotent function may have a side effect the first time you run it. Subsequent updates won’t change things further, but the first run does.


#### 6장 정리
- 지금까지 나온 건 책임주도설계를 잘 하면 대충 적용됨
- 런타임에 제약조건을 만들 수 없음 (인터페이스 등은 다 컴파일타임) - `Design By Contract` 제안
