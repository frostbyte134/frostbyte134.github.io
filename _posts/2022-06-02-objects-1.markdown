---
layout: post
title:  "Objects - 코드로 이해하는 객체지향 설계 Chap4, 5, 6"
date:   2022-05-31 08:00:05 +0800
categories: coding
use_math: true
tags: coding
---

블로그 어카지 ㄷㄷ AWS로 옮기고 싶긴 한데 latex이 좀....

훌륭한 설계란 합리적인 비용 안에서 수용가능한 구조를 만드는 것 (= 응집도가 높고 느슨하게 결합된 구조)

### Chap 4
- 협력: APP 기능구현을 위해, 메시지를 주고받는 객체들 간 상호작용
- 책임: 협력을 위해 객체가 수행하는 행동
- 역할: 대체가능한 책임의 집합 (약간 인터페이스 느낌)

결국 책임이 제일 conerstone임 (책임주도설계란 말이 있는 이유)

> 객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다 [Evers09]

해설
1. 책임이 젤 중요
2. 책임을 잘 할당하면 결합도/응집도도 잘 풀린다
3. 책임에 초점을 둔다 = 객체의 상태보단 행동에 초점 둔다

#### 데이터 중심 vs 책임 중심
시스템을 분할하는 2가지 방법 = 상태중심 / 책임중심 분할
1. 상태중심 분할 - 상태(데이터)는 구현에 따라 바뀜 (자주 변함)
  - 데이터(멤버변수)부터 고려 -> 이 후 협력 생각
  - 협력이 먼저 완성된 데이터 구조 참고 -> 이미 완성된 데이터에 대한 지식이 인터페이스에 드러나게 됨
2. 책임중심 분할 - 책임은 인터페이스에 속함 - 상대적으로 불변

캡슐화란 변경가능성이 높은 부분을 내부로 숨기는 것
 - 데이터 중심으로 설계하고 getter, setter를 자동생성하는건 캡슐화에 전혀 (!) 도움이 안됨
 - `추측에 의한 설계`: __책임중심으로 설계하지 않고 데이터중심으로 설계했기 떄문에, 어떤 협력 컨텍스트에서 객체가 쓰일 지 감이 안잡힘 -> 항상 쓸 수 있게 게터, 세터 추가__
 - 인터페이스를 변경하지 않고 내부 구현만 변경해도, 관련된 getter, setter를 다 변경해야 함
 - 이 객체를 갖다쓰는 쪽에서는, 사실상 내부 구조(상태)를 다 아는 것 (캡슐화 X) -> 결합도 up
 - 객체가 자기 자신에 대해 책임지게 함으로서, 캡슐화를 높일 수 있음 (외부에서 내부 로직을 다 알고 조종하면, 이런 외부가 많아질 때 관리포인트가 늘어남)

멤버변수별로 getter/setter가 있는 것 외에도 구현 노출 (=캡슐화 X)인 경우는 많음
- 함수 시그니처의 파라미터 타입으로 내부 변수 타입 노출
- 함수 종류 (`calcAmountDiscountedFee`, `calcPercentDiscountedFee`, `calcNoneDiscountedFee`)로 할인 종류 노출 (할인 종류별로 메소드를 만들지 말고, 내부 상태로 숨겨서 처리할 수도 있을 듯)
- `정리하면 캡슐화란 변하는 어떤 것이든 감추는 것이다`


유지보수성이란 두려움 없이 코드를 변경할 수 있는 능력

#### 응집도 vs 결합도
응집도 (`cohesion`)
- 높은 응집도
  - 모듈의 요소들이 하나의 목적을 위해 협력
  - 변경이 발생할 떄 모듈 하나에서 해당 모듈 전체가 수정 (!)
- 낮은 응집도
  - 서로 다른 목적을 추구 
  - 변경이 발생할 시 여러 모듈들에서 각자의 일부만 수정

SRP (단일 책임 원칙)
 - 클래스는 단 하나의 변경 이유만 가져야 함
 - 높은 응집도를 위한 것


결합도 `coupling`
- 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 척도
- 응집도와 독립적인 개념이 아님

결합도가 높아도 되는 경우 - 변경여지가 작은 퍼블릭 모듈 (자바의 ArrayList)에 대한 결합도
