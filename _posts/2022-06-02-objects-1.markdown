---
layout: post
title:  "Objects - 코드로 이해하는 객체지향 설계 Chap4, 5, 6"
date:   2022-06-02 08:00:05 +0800
categories: coding
use_math: true
tags: coding
---

블로그 어카지 ㄷㄷ AWS로 옮기고 싶긴 한데 latex이 좀....

훌륭한 설계란 합리적인 비용 안에서 수용가능한 구조를 만드는 것 (= 응집도가 높고 느슨하게 결합된 구조)

### Chap 4
- 협력: APP 기능구현을 위해, 메시지를 주고받는 객체들 간 상호작용
- 책임: 협력을 위해 객체가 수행하는 행동
- 역할: 대체가능한 책임의 집합 (약간 인터페이스 느낌)

결국 책임이 제일 conerstone임 (맨 밑에 있음. 책임주도설계란 말이 있는 이유)

> 객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다 [Evers09]

해설
1. 책임이 젤 중요
2. 책임을 잘 할당하면 결합도/응집도도 잘 풀린다
3. 책임에 초점을 둔다 = 객체의 상태보단 행동에 초점을 둔다

#### 데이터 중심 vs 책임 중심
시스템을 분할하는 2가지 방법 = 상태중심 / 책임중심 분할
1. 상태중심 분할 - 상태(데이터)는 구현에 따라 바뀜 (자주 변함)
  - 데이터(멤버변수)부터 고려 -> 이 후 협력 생각
  - 협력이 먼저 완성된 데이터 구조 참고 -> 이미 완성된 데이터에 대한 지식이 인터페이스에 드러나게 됨
2. 책임중심 분할 - 책임은 인터페이스에 속함 - 상대적으로 불변

캡슐화란 변경가능성이 높은 부분을 내부로 숨기는 것
 - 데이터 중심으로 설계하고 getter, setter를 자동생성하는건 캡슐화에 전혀 (!) 도움이 안됨
 - `추측에 의한 설계`: __책임중심으로 설계하지 않고 데이터중심으로 설계했기 떄문에, 어떤 협력 컨텍스트에서 객체가 쓰일 지 감이 안잡힘 -> 항상 쓸 수 있게 게터, 세터 추가__
 - 인터페이스를 변경하지 않고 내부 구현만 변경해도, 관련된 getter, setter를 다 변경해야 함
 - 이 객체를 갖다쓰는 쪽에서는, 사실상 내부 구조(상태)를 다 아는 것 (캡슐화 X) -> 결합도 up
 - 객체가 자기 자신에 대해 책임지게 함으로서, 캡슐화를 높일 수 있음 (외부에서 내부 로직을 다 알고 조종하면, 이런 외부가 많아질 때 관리포인트가 늘어남)

멤버변수별로 getter/setter가 있는 것 외에도 구현 노출 (=캡슐화 X)인 경우는 많음
- 함수 시그니처의 파라미터 타입으로 내부 변수 타입 노출
- 함수 종류 (`calcAmountDiscountedFee`, `calcPercentDiscountedFee`, `calcNoneDiscountedFee`)로 할인 종류 노출 (할인 종류별로 메소드를 만들지 말고, 내부 상태로 숨겨서 처리할 수도 있을 듯)
- `정리하면 캡슐화란 변하는 어떤 것이든 감추는 것이다`


유지보수성이란 두려움 없이 코드를 변경할 수 있는 능력

#### 응집도 vs 결합도
응집도 (`cohesion`)
- 높은 응집도
  - 모듈의 요소들이 하나의 목적을 위해 협력
  - 변경이 발생할 떄 모듈 하나에서 해당 모듈 전체가 수정 (!)
- 낮은 응집도
  - 서로 다른 목적을 추구 
  - 변경이 발생할 시 여러 모듈들에서 각자의 일부만 수정

SRP (단일 책임 원칙)
 - 클래스는 단 하나의 변경 이유만 가져야 함
 - 높은 응집도를 위한 것


결합도 `coupling`
- 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 척도
- 응집도와 독립적인 개념이 아님

결합도가 높아도 되는 경우 - 변경여지가 작은 퍼블릭 모듈 (자바의 ArrayList)에 대한 결합도


### Chap 5 책임 할당하기
책임 할당 = 트레이드오프 (동일한 문제를 다양하게 해결가능, 상황/문맥에 따라 트레이드오프가 생김)

2가지 원칙
- 데이터보다 행동(책임)을 먼저 결정하라
- 협력이라는 문맥 안에서 책임을 정의/결정하라
  - 객체 입장에선 책임이 어색해도 협력에 적합하다면 좋은 책임 할당임
  - 클래스를 결정하고 그 클래스의 책임을 찾기 = X
  - 메시지를 결정하고 메시지를 누구에게 전송할지 찾기 = O
  - > 객체를 갖고 있기 때문에 메시지를 보내는 것이 아니다. 메시지를 전송하기 떄문에 객체를 갖게 된 것이다 [Metz12]
  - 메시지를 먼저 결정 - 수신자에 대헤 가정하기 어려움 - 자동적으로 캡슐화 - (높은 응집도 + 낮은 결합도)


책임 주도 설계
- 시스템 책임 (전체 책임) 파악 - 작은 책임으로 분할 (여기서 어느정도 책임/메시지 정의가 됨)
- 작은 책임을 수행가능한 객체/역할을 찾아 책임 할당
  - 도움이 필요하거나 책임이 좀 큰 경우, 나눌 객체를 찾아 책임 할당 + 메시지 정의

#### 책임 할당을 위한 GRASP 패턴
General Responsibility Assignment Software Pattern (Craig Larman)
1. 시작점 = domain concepts
  - 도메인 모델도 구현에서 자유로울수는 없음 - 구현을 염두에 두고 도메인 개념들을 구조화하는 것도 중요
2. `INFORMATION EXPERT` 패턴
  - 책임을 정보 전문가에게 할당
  - 정보 != 데이터(멤버변수). 해당 정보를 제공가능한 다른 객체를 __알고__ 있거나, on the fly로 계산할수도 있음
  - 가장 기본
3. `LOW COUPLING` 패턴, `HIGH COHESION` 패턴 
4. `CREATOR`패턴 - 이미 있는 관계 이용
  - B가 A를 포함/참조
  - B가 A를 기록 / 긴밀하게 사용
  - B가 A를 초기화하는데 필요한 데이터를 갖고 있음 (= B는 A에 대한 정보 전문가)
  - 이 경우 B에게 A객체 생성 책임을 맡기면 좋음 (낮은 결합도로 이어짐)


메시지를 보낼 때, raw type보단 객체를 보내는 게 캡슐화에 좋은 듯?
- 아니 근데 이러면 디펜던시가 또 생기는데.. (147p 별표)
- ex) screening이 movie객체에 `calculateMovieFee(Screening screening)`메시지를 보낼 때, screening객체를 보냄으로서 movie의 구현을 몰라도 되게 설계 -> 캡슐화 (movie의 자율성 보장)
  - 반대로 말하면 이걸 받는 movie쪽에선 screening의 구현을 (인터페이스를 통해서라도) 알 수 있는 거 아닌가? 그나물에 그밥 같은데..

#### SRP와 응집도
- 150p의 DiscountCondition은 변경이유 종류가 다양함 (할인조건 추가, 순번조건 판단 변경, 기간조건 판단 변경) - __응집도가 낮다__
  - 변경 이유에 따라 클래스 분해

설계 개선은 SRP원칙 위배를 찾는걸로 시작하는 게 좋음 (`PROTECTED VARIATIONS` 패턴 = 설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 (인터페이스 뒤로?) 캡슐화하라)  
- __위험징후 패턴 존재__
  1. 내부 상태 초기화가 한번에 되지 않고 나뉘어서 됨. 시간순으로 나뉘는 경우도 있고, 조건에 따라 일부 변수에는 값이 안들어오는 경우도 있음
  2. 메서드들이 사용하는 내부 상테에 따라 클러스터링 될 수 있을 때

분리한 것들이 비슷한 인터페이스를 지니게 되면 다형성을 통해 관리하는 것도 좋음
 - 분리된 클래스들이 같은 역할을 다르게 수행하는 경우 (책임은 살짝 다르지만)
 - `POLYMORPHISM` 패턴 (다형성 패턴)
  - 객체의 타입에 따라 변하는 행동이 있다면, 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당
  - 되도록이면 if-else 보다는 다형성으로 분기

마지막에 무비를 분리하는 부분은 좀 맘에 들진 않았음...

구현을 가이드할 수 있도록 도메인 모델을 선택하라 (만들지도 않았는데 구현을 어케 암 ㅋㅋ)


#### 리펙토링 - 긴 메서드

몬스터 메서드 (`monster method`)의 단점
- 이해가 어려움 (어디를 변경해야 할 지 찾기어려움)
- 단일 변경이 미치는 범위가 넓어짐
- 일부만 재사용하기 어려움 - 중복 초래 가능성
- 응집도가 높기 어려움 (아무래도 이상한 게 끼어 있겠지...)

책임 주도 설계에 익숙하지 않으면, 데이터 중심 설게를 하고 리팩토링해도 비슷한 효과를 얻을 수 있다 (....)고 합니다~