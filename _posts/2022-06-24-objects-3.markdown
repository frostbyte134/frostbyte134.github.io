---
layout: post
title:  "Objects - 코드로 이해하는 객체지향 설계 Chap10, 11, 12"
date:   2022-06-24 08:00:05 +0800
categories: coding
use_math: true
tags: coding
---


### Chap 10

객채지향의 장점 중 하나 - 코드 재사용  
객체지향에서는 __코드를 재사용하기 위해 새로운 코드를 추가__
- `상속`: 클래스를 재사용하기 위해 새로운 클래스를 추가
- `합성`: 새 크래스 객체 안에 기존 클래스의 인스턴스 포함

`DRY`원칙
- Dont Repeat Yourself
- 코드 중복 여부 = 변경 시 같이 변경되는가. 코드 모양이 유사하다는 것은 중복의 징후일 뿐임
- 중복 코드는 변경을 방해한다. 이것이 중복코드를 제거해야하는 가장 큰 이유다
- 중복 코드는 (서로) 다르게 변경하기도 쉬움 -> 로직이 요구사항과 틀리게 될 가능성이 높음
- 중복 코드를 제거하지 않고 코드를 수정할 수 있는 유일한 방법은 새로운 중복코드를 추가하는 것 뿐이다

#### 중복과 변경
중복제거의 방법 중 하나 - 클래스를 하나로 합치고, 내부에서 조건문으로 판단
- OOP는 조건문 대신 타입으로 런타임에 분기를 탈 수 있음 (`상속`)

상속의 문제
- 상속 하이어라키 상에서 (=부모 클래스들에서) 개발자가 만든 가정을 다 이해해야 함
- 결합도가 높아짐 -> 이 강한 결합도가 코드를 수정하기 어렵게 만든다
- 자식 클래스가 super참조를 이용해 부모클래스의 메서드를 호출할 경우, 결합도가 너무 큰 것임 - 제거해야 함

#### 취약한 기반 클래스 문제
상속은 자식과 부모 클래스 간의 결합도를 높인다
- 핵심적인 기반 클래스에 대한 단순변경이 생겼다고 가정
  - 모든 기반클래스 + 파생클래스의 메서드들을 다 테스트해야 함 
- __취약한 기반 클래스 문제는 상속이라는 문맥 안에서 결합도가 초래하는 문제점을 가리키는 용어다__. 상속 관계를 추가할수록 전체시스템의 결합도가 높아진다는 사실을 알고 있어야 한다.
- 상속은 자식클래스를 점진적으로 추가해서 기능을 확장하는데는 용이하지만, 높은 결합도로 인해 부모 클래스를 개선하는 것은 어렵게 만든다
- 상속은 __자식클래스가 부모클래스의 구현 세부사항에 의존하도록 만들기 때문에 캡슐화를 약화시킨다__
- 캡슐화 - 구현 세부사항을 인터페이스 뒤로 숨겨서, 변경의 파급범위를 제어
  - 상속은 캡슐화를 쉽개 깰 수 있음 (부모-자식 간)

상속받은 부모 클래스의 메서드가 자식클래스의 로직을 깨트릴 수 있다
- 불필요한 인터페이스까지 다 상속받게 됨. 실제 상속관계 (강한 결합도)로 완벽하게 표현할 수 있는 관계는 많지 않음

메서드 오버라이딩할 경우, 부모클래스가 자신의 메서드를 사용하는 방법에 자식클래스가 결합될 수 있다
- Joshua Bloch said..
  - 오버라이딩 가능한 메서드를 호출하는 모든 상황에 대해 문서화해야 함. but 잘된 API문서는 메서드의 what만을 기술하고 how는 기술하면 안됨 - 상속이 캡슐화를 위반함으로서 생기는 문제. __서브클래스가 안전하게금 클래스를 문서화하려면, (어쩔 수 없이) 클래스의 상세 구현 내역을 기술해야 한다__
  - 상속을 위해 설계된 슈퍼클래스가 아닐 경우, 결합도가 너무 강해짐. 서브클래스를 변경하지 않았더라도 슈퍼클래스의 변경에 의해 서브클래스가 꺠질 수 있음.


#### '위로 올리기' 전략
1. 공통메서드 추출
2. 부모-자식 관계 말고, 자식을 부모로 올린 뒤 둘 다 공통 추상클래스에 의존하개
  - 중복코드는 추상클래스에, 추출한 메서드만 따로 구현


#### 차이에 의한 프로그래밍
상속은 강력한 도구임
- 익숙한 개념을 이용해 새로운 개념을 쉽고 빠르게 추가가능
- 기존 코드와 다른 부분만 추가해서 기능 확장 = `차이에 의한 프로그래밍`
- 상속을 잘 이용하면 앱의 점진적인 정의 (incremental definition)가 가능해짐
- but 지나친 결합도 때문에, 많은 경우 우아한 해결법이 아님 -> 합성


### Chap 11 합성과 유연한 설계

상속, 합성은 둘 다 코드 재사용을 위한 기법
- 상속: is-a, 부모 클래스의 구현(코드) 재사용, 의존성을 컴파일타임에 해결 (정적)
  - `화이트박스 재사용` whitebox reuse (구현을 알고 재사용)
  - 부모의 코드 대부분을 물려받음 - 결합도가 올라감
- 합성: has-a, 객체 자체를 재사용, 의존성을 런타임에 해결
  - `블랙박스 재사용` blackbox reuse (구현을 모르고 인터페이스만 알고 사용)
  - 구현이 아닌 퍼블릭 인터페이스에 의존 (동적)

`몽키패치` monkey patch
- 실행 중 환경에만 영향을 미치도록 지역적으로 코드를 수정/확장하는 것


#### 상속의 문제

`훅 메서드` hook method
- 추상 메서드와 동일하게 자식클래스에서 오버라이딩할 의도로 메서드를 추가했지만 편의를 위해 기본 구현을 제공하는 메서드

구현 재사용이기 때문에 생기는 문제들
- 연산 순서 등의 제약이 추가적으로 붙는 경우, 특정 연산순서마다 서브클래스를 만들어야 함

ex) 부모.func1 호출 후 자식func2호출해야 하는 경우
1. 자식 메서드에서 super를 이용해 부모의 함수 호출
  - 부모의 메서드가 변경될 경우, 모든 자식메서드를 수정해야 함. 해당 메서드에 특정 가정이 있는 경우도 관리 어려움
2. 이 경우 아예 부모에서 추상메서드를 제공하고, 부모에서 func1호출 후 (자식이 구현하게 될) 추상.func2를 호출하면 그나마 나음 (OCP 조금 만족)
  - 그러나 이경우에도 클래스 갯수의 지수적 증가를 막기는 어려움
  - 모든 자식이 이 메서드를 구현해야 하기도 함

기능수정시에도 문제가 됨

#### 합성관계로 변경
합성은 컴파일타임 관계를 런타임으로 변경함으로서 이 문제를 해결한다
- 합성을 사용하면 구현이 아닌 퍼블릭 인터페이스에만 의존할 수 있기 때문에 런타임에 객체간의 관계 (ex - 순서)를 변경할 수 있다 - 유연해 지는 것은 맞음
- 코드 읽기가 어려워지긴 함 (런타임에 실제 관계가 정해지므로)

> 대부분의 경우 단순한 설계가 정답이지만, 변경에 따르는 고통 > 복잡성으로 인한 혼란이라면 유연성이 더 선호됨

합성의 구현
- 대상이 되는 (작은) 객체에 대해 내부에 참조자 포함, 직접 생성하거나 (SRP어기므로 대부분 bad) 주입받음
- 순서도 (동류의) 인터페이스를 내부에서 합성하는 것으로 해결

상속을 사용해서는 안 되는 것인가?
- __위의 단점은 모두 구현상속임__
- 인터페이스 상속은 좋음 (chap 13)

#### 믹스인
상속과 비슷하긴 함. but
- 상속의 목적 - is-a 관계를 만드는 것
- mixin의 목적 - 컴파일 시점에 필요한 코드조각을 재사용하는 것 (런타임이 아님!)
  - 뭔가 상속 - 합성의 중간인 듯. 재사용은 되는데 런타임이 아니라 컴파일타임
  - '코드를 다른 코드 안에 유연하게 섞어 넣을 수 있다면 믹스인이라고 할 수 있다'
  - super의 대상이 컴파일타임에 비교적 유연하게 정해짐

스칼라의 mixin과 linearization
- class: class로 선언, extends로 상속받음
- mixin: trait으로 mixin 선언, with으로 상속받음

```
class A{

}


trait B extends A{

}

class C
  extends A
  with B
```

- super.func1 - `linearization`으로 정해진 순서대로, func1이 있는 클래스 탐색 -> 발견하면 그 클래스의 func1호출
  - 자기 자신이 우선, 그 뒤로 아래서부터 찾아감 (맞나?)
- __실제로 with으로 믹스인되기 전까진 상속 계층에서 위치가 고정된 것이 아님__
- 상속처럼 클래스 갯수가 기하급수적으로 늘어나긴 함
  - but 중복코드는 늘어나지 않으므로 노상관

`추상 서브클래스` (추상 슈퍼클래스거 아님)
- 보통 OOP에선 슈퍼클래스는 서브클래스를 명시하지 않고 정의되나 그 반대는 안됨
- 어떻게보면 mixin은 그 반대라고 볼 수 있음 (슈퍼클래스를 빈칸으로 두고 서브클래스 정의)
- Martin Odersky (누구?) - mixin은 stackable modification


### Chap 12 다형성
