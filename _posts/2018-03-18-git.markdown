---
layout: post
title:  "Git (egoing)"
date:   2018-03-18 09:26:00
categories: coding
use_math: true
tags: coding git
---


<a href="https://seomal.org/" target="_blank">https://seomal.org/</a>

`HEAD` - working tree를 가르킴

__git is immutable__

버전관리의 목적: 파일의 이름을 더럽히지 않고 관리하기

.git 파일: repository (version이 만들어지는 곳)
작업중인 폴더: working directory

stage area = index = cache

`Gistory` (python)

<그림 1>
master 와 checkout된 commit은 1대1 관계를 가짐

파일명이 같아도 git은 내용을 따로 관리 (objects폴더에 본체 존재)
파일명이 달라도 내용이 같으면, 같은 objects/\*\*를 가르킴 (content 기반 hash)

git log를 눌렀을 때
1. git은 .git/HEAD를 참조
2. HEAD는 보통, ref: refs/heads/master가 적혀 있음. checkout시 refs/heads/master가 해당 checkout한 commit으로 바뀜
3. 해당 파일을 열어 보면, master가 가르키는 commit이 있음.
4. 해당 commit은, tree(생성 시 파일의 이름, 데이터(obejcts/**에 대한 reference 형태) 보유) / parent 2개의 포인트를 보유. 

git은 모든데이터를 object로 관리.  
object 종류
* tree: 이름
* blob: 파일
* commit

git file management
- `working dir` ->(add)-> `stage` ->(commit)-> `repo`

git add <filename>
- <file>을 staging 시키겠다
- index에 파일 등록 (새로 staging 되는 파일은 .git/objects에 저장)
  
git commit
- working dir -> repo
- -a 옵션: add생략가능 (unstaged file은 안됨)
- --amend: 현재 head가 가르키는 commit 수정하기 (파일 내용은 add로 stage에 올려놔야 수정됨)

git checkout
- __head__ 옮기기
  - git의 head란?
    working copy의 origin
- 원래대로 가려면 checkout to master
- head 와 current branch (보통 master)를 분리할 수도 있음

git reset
- 삭제 효과가 있지만 실제 삭제는 아님 (reset --hard로 원래 working dir로 복귀가능!) 
-  branch를 옮기는 것 (__딸린 head가 있다면 head도 같이 옮겨감__) - master가 바라보는 commit ID를 바꾸는 것
- working directory의 unstaged된것들 다 지우기: git reset --hard HEAD (master로 복귀하면 의미가 좀 다름)
- commitID를 받을수도 있음

git revert
- 삭제한 효과가 나면서 기능을 유지한다
- `git revert commitID`: commitID를 취소한 새로운 commit을 생성
- git revert를 sequential하게 해주면 충돌이 안난다고 함

git reflog
- (원인): 결과
- commit, checkout, reset 결과
- reset으로 지워버려도 여기서 commitID를 참조해서 복귀가능
- HEAD@{N}: N번 전에는 해당 상태였다. 이를 이용해 reset도 가능
  - git reset --hard HEAD@{5} : undo before 5th action (go to corresponding commit id)

git status
- add 되었는지 확인
- 현재 dir의 상태를 보여줘 (commit 대기)

git diff
- (working dir)의 1~2줄정도 주위의 변화도 같이 보여줌

git branch
* ref/heads에 각 branch가 가르키는 commit 주소가 있음
* checkout으로 head를 옮겨 다른 branch를 가르킬 수 있음
* git branch -d \<branch name\> : removing branch

`base`: branch들의 공통의 조상

git merge
* fast forward / merge commit 2가지 방법이 있음
1. fast forward: 앞서나간 branch를 따라잡기.  
뒷 branch로 checkout 후 merge 앞 브랜치와 병합  
충돌이 절대 일어나지 않음
2. merge commit: 서로 다르게 뻗어나간 branch들을 commit으로 병합
  * conflict는 주변 1~2줄도 봄

git 3-way merge
* 최대한 많이 자동 병합하기 위한 기능?

merge후 복귀하기
* git은 위험한 작업을 하기 전에 (merge등), ORIG_HEAD로 HEAD를 복사해 놓음. 따라서 git reset --hard ORIG_HEAD를 하면 merge가 취소됨.
* 아니면 reflog로 commit

`snapshot`: 버전(?)이 만들어진 당시 working dir의 copy

`change`: snapshot끼리의 차이? 베이스와?

git rebase
* base를 옮길 branch로 checkout 후, git rebase <대상이 될 브랜치>로 해야 함

miscs
- git add filename : 변경사항 스테이징 에어리어에 등록
- git commit -m "comments"
- git checkout (branchname/master) : 워킹트리 변경
- git tag : 현 워킹트리버전에 태그 붙이기


### 1일차 정리
* 저장소 생성시 init 
* git add <filename> : track (on stage)
* git status 
* git 저장소의 상태 : working directory - stage area (index파일, cache) - commit시 버전이 만들어지면서 repo에 저장됨
* git commit -a(add all, except untracted) -m <message>   
* git log --oneline --all -p (각각의 차이점)
* git reset version [--hard] : 버전 지우기. branch가 가르키는 commitID를 바꾼다
* git checkout [-b : branch생성] (branch name | commit id): head가 가르키는 commitID를 바꾼다
* git branch (단순 branch읽기) [-d branch_name: 삭제] 
* git checkout 병합할 브랜치 && git merge 병합될 branch
* git mergetool: conflict 해결용 merge tool
* conflict manual 해결후 git add 
* git checkout 리베이스를 할 (베이스를 옮길) 브랜치 && git rebase (대상이 될 브랜치)
  
<a href="https://dogfeet.github.io/articles/2012/git-merge-rebase.html" target="_blank">rebase vs merge</a>
