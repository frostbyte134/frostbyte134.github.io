---
layout: post
title:  "객체지향의 사실과 오해"
date:   2021-12-29 08:00:05 +0800
categories: coding
use_math: true
tags: coding python
---

> 객체지향의 사실과 오해 역할, 책임, 협력 관점에서 본 객체지향 (조영호 저)

복습용 요약
- 시스템은 역할과 책임을 수행하는 객체들로 구성
- 객체가 시스템상에서 가지는 의미는 행동에서 나오기 떄문에, 설계에서 행동을 먼저 생각하는 것이 맞음

> 추상화 - 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.   
복잡성을 다루기 위해 추상화는 두 차원에서 이뤄진다  
- 첫 번째 차원은 __구체적인 사물들 간의 공통점을 취하고 차이점을 버리는 일반화를__ 통해 단순하게 만드는 것이다.
- 두 번째 차원은 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로서 단순하게 만드는 것이다  
모든 경우에 추상화의 목적은 복잡성을 이해하기 쉬운 수준으로 단순화하는 것이라는 점을 기억하라 - Kramer, Is abstraction the key to computing?

역할은 객체의 페르소나다 (협업에서 중요한 건 외부와의 상호작용을 하는 역할이지 내부 상태가 아님)
- __행동이 상태를 결정한다__
- 어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 행동이다
   - 덕타이핑은 좀 다름. 덕타이핑엔 (동적 상속 + __타입 검사를 생략한다__ ) 는 의미가 있는 듯 
- 내부 표현 (상태)는 자율적임 (캡슐화)
   - 내부 표현 방식이 다르기 때문에, 같은 타입에 속해도 (수행하는 행동이 같아도) 동일한 메시지를 내부적으로 다르게 처리할 수 있음 = 다형성
- 역할을 대체할 수 있는 객체는 동일한 메시지를 이해할 수 있는 객체로 한정됨

책임 
 - 외부에 대해 해줄 수 있는 것 (doing) / 제공해 줄 수 있는 것 (knowing)으로 나뉨 = __책임은 객체의 공용 인터페이스가 됨__
 - 객체가 다른 객체에게 책임을 수행하도록 요청을 보내는 것을 `메시지 전송`이라고 한다. 보통 하나의 책임이 여러 메시지로 분해되는 것이 일반적
 - 어떤 객체가 수행하는 책임의 집합은 객체가 협력 안에서 수행하는 역할을 암시한다
 - 객체에게 책임을 할당하고 이를 구현하면 행동이 됨


패턴 = 특정 문제에 대한 역할, 책임, 협력의 best practice

다형성
 - 송신자와 수신자 간의 객체 타엡이 대한 결합도를 메시지에 대한 결합도로 낮춤으로서 달성됨 (재사용성, 유연한 협력)
 - 동일한 역할을 수행할 수 있는 객체들 간의 대체 가능성을 의미함
 
OOP 어플리케이션은 클래스로 만들어지지만 메시지로 정의됨


TDD의 테스트 = 책임을 수행할 객체가 메시지를 수신할 때 어떤 결과를 반환하고, 그 과정에서 어떻게 다른 객체와 협력할 것인지를 코드의 형태로 작성한 것

클래스
 - 객체지향의 정적인 측면을 표현
 - 객체를 표현하고 생성하기 위해 개발언어가 제공하는 구현 메커니즘 (일 뿐임. 클래스가 없는 OOP 언어도 있음)
 - OOP 어플리케이션은 클래스로 만들어지지만 메시지로 정의됨
    - 클래스 (or 데이터)에 초점을 둔 설계는 유연하지 못하고 확장하기 어렵다
    - 객체의 내부 구조를 정의에 포함시키면 안됨. 협력이라는 문맥 안에서의 역할/행동으로 

자율성을 보장하기 위한 방법
- 객체의 외부와 내부를 분리 (`encapsulation`) (=구현과 인터페이스를 분리)
   - 객체의 외부와 내부는 메시지를 기준으로 분리됨 
   - 내부 = 구현, 외부 = 인터페이스 (결과적으로 메세지, 책임 등을 전부 포함하는)
   - SW는 항상 변경 - 변경에 대한 안전지대 (인터페이스)를 만드는 것이 중요. 이 부분에 의존해 객체의 자율성을 발휘할 수도 있음
   - 객체는 다른 객체가 무엇(what)을 하는지는 알 수 있지만 내부적으로 어떻게(how) 하는지는 알 수 없다 (알면 안됨)
      - 책임이 자율적인 경우 책임을 수행하는 내부적인 방법을 변경하더라도 외부에 영향이 없음
      - 어떻게 보다는 무엇에 초점을 두기 때문에, 변경이 쉬움
- 메시지 (외부 요청을 기술하는 spec)와 메서드 (요청을 처리하는 방법)을 분리
- 데이터와 행동을 따로 고려하지 않고, 객체라는 카테고리에 묶어서 관리
   - 상태(데이터)보다는 행동(책임, 메시지)를 먼저 


> 객체지향이 과거 개발방법에 비해 더 유연하고 재사용가능하다고 알려진 이유 = 객체의 외부와 내부를 명확히 구분하기 때문 (= 객체의 자율성을 보장)

다형성은 송신자와 수신자 간의 객체 타엡이 대한 결합도를 메시지에 대한 결합도로 낮춤으로서 달성됨 (재사용성, 유연한 협력)

`캡슐화` (encapsulation)
- 객체가 외부에 노출하는 것은 행동뿐이며, 외부에서 객체에 접근할 수 있는 유일한 방법 역시 행동뿐이다
- 객체의 상태는 객체가 행동을 통해 직접 변경하여야 함 (자율성)


부록 (아직 정리 안함)
- 객체들을 공통적인  특성을 기반으로 범주로 묶고 개념을 적용하는 것은, __범주라는 렌즈를 통해 세상을 바라보는 것과 유사하다.__
- 객체에 개념(의 내연)을 적용하는 과정을 분류라고 한다
- 객체지향에서 개념을 가르키는 표준 용어는 타입이다. 따라서 타입은 개념과 동의어이며 속성과 행위가 유사한 객체에 공통적으로 적용되는 관념/아이디어를 의미함
- 도메인을 분석하는 동안 (도중 식별된) 이름, 의미, 객체 집합을 이용해 개념을 정의할 수 있다
- 타입은 보통 클래스를 이용해 구현됨 (따라서 둘이 동일하지는 않음)
- 생물 분류 체계 - __계층적__
   - 슈퍼타입을 공유한다는 것 만으로, 많은 특성 유추 가능 (ex - 포유류 = 젖을 먹음)
- OOP에서 계층 구현
   1. 슈퍼타입 - 서브타입 (is-a)
   2. has-a (composition): 객체간의 관계를 잘 설정할 경우, 복잡함을 객체 단위로 감출 수 있음. 이 경우 추상화 (계층구조 구현)와 캡슐화 (복잡함 감추기) 동시에 적용
- 서브타이핑 vs 서브클래싱: 슈퍼클래스를 완전히 대체가능하면 서브타이핑, 아니면 서브클래싱. 서브클래싱의 경우 메시지 처리 불가 - 슈퍼클래스로 역순으로 올라감 (= 클래스 간 `위임` delegation)
- 클래스만으로 계층구조 표현이 어려운 경우 = 클래스를 묶은 모듈도 상위에 활용가능

### 01 협력하는 객체들의 공동체

객체지향의 목표 != 실세계 모방. 실세계에 대한 비유는 시스템을 이해하는 데에만 효과적
- sw상의 객체는 실제 객체보다 능동적 (ex - 음료수 객체는 자기자신의 액채량을 알아서 줄임)
- 다만 sw상의 객체를 실제 객체의 은유를 사용해 디자인하면 이해가 쉬움

객체지향에서 가장 중요한 개념: `협력, 역할, 책임`
- 협력: 요청/응답으로 구성
   - 요청은 연쇄적으로 (책임이 있는 객체들에게 sequential하게) 발생, 응답은 그 역순
- 특정한 역할은 특정한 책임을 암시 
   - ex) 선생님: 담당 학생 교육에 책임이 있음
   - __역할은 관련된 책임의 집합__
      - 역할은 대체가능함 
      - 단일객체가 여러 책임을 질 수도 있음 (이런 디자인이 좋은가는 둘째치고서라도)
   - 역할은 객체의 페르소나다 (협업에서 중요한 건 외부와의 상호작용을 하는 역할이지 내부 상태가 아님)
   - 역할은 __유연하고 재사용 가능한 협력 관계__ 를 구축하는 데 중요함


#### 객체지향에서 `시스템`의 정의
- 시스템은 역할과 책임을 수행하는 객체들로 구성
- 시스템의 기능 = 객체 간 연쇄적인 요청/응답
- 객체지향 설계는 적절한 객체에게 적절한 책임을 할당하는 것에서 시작된다. 책임이 불분명한 객체는 앱의 미래 역시 불분명하게 만든다


#### 객체 (object)
- 객체지향 패러다임의 중심, 실제로 협력을 수행하는 주체
- 객체는 협력적이야 하며, 동시에 자율적이기도 해야 함
   - 아주 작은 기능조차 객체 혼자 감당하기엔 복잡하기 때문에, 일반적으로 객체는 다른 객체와의 협력을 통해 기능을 구현한다
   - 자율적이지 않으면 모듈/객체단위로 끊어서 보기 힘드므로..
- 흔히 객체를 __상태와 행동을 지닌 실체__ 로 정의
   - 행동에 필요한 상태를 스스로 갖고 있어여 함 (자율성 보장)
   - 객체의 자율성은 내부와 외부를 명확하게 구분하는 것으로부터 나온다 ... 객체는 다른 객체가 무엇(what)을 하는지는 알 수 있지만 어떻게(how)는 알 수 없다 (알면 안됨)
      - 과거(전통적 개발): 데이터/프로세스를 구분
      - oop: 데이터(상태) / 프로세스(행동)을 묶어서 관리 - 자율성을 통해 유지보수 향상 기대 (양날의 검인듯)


#### 메시지
- 객체지향에서는 오직 한 가지 의사소통만 존재: 메시지
- 협력: 메시지의 송신자 (`sender`) / 수신자 (`receiver`) 사이에서 일어남
- `method`: 객체가 수신된 메시지를 처리하는 방법
- 메시지 (외부요청을 기술)와 메서드(요청을 처리하기 위한 구체적인 방법)를 분리하는 것은 객체의 자율성을 높이는 핵심 메커니즘이다. ( - 캡슐화 `encapsulation`와도 관련있음)


(요약) 객체지향이란?
- 시스템 = 상호작용하는 객체들의 집합
   - 자율적인 객체: 상태와 행위를 지니며 스스로 자기자신을 책임짐
- 객체는 시스템의 행위를 구현하기 위해 다른 객체와 협력. 각 각체는 협력 내에서 정해진 역할을 수행하며, 역할은 관련된 책임의 집합
- 관점 
   - 코드를 담는 클래스 (X) vs 메시지로 협력하는 객체들 (O)
   - 중요한 것은 어떤 클래스가 필요한가, UML은 어떻게 구성하나가 아니고 어떤 객체들이 어떤 메시지를 주고받고 협력하는가이다


### 02 이상한 나라의 객체

> 객체지향 패러다임은 지식을 추상화하고 이를 객체 안에 캡슐화함으로서 실세계 문제에 내재된 복잡성을 관리하려고 한다. 객체를 발견하고 창조하는 것은 지식과 행동을 구조화하는 문제다. - Rebecca Wirts-Brock, 1990

객체의 바운더리
- 세상을 작은 객체로 분해하는 것은 복잡성을 극복하려는 인간의 몸부림이다 ... 즉 객체는 인간이 분명하게 인지하고 구별할 수 있는 물리적/개념적인 경계를 지닌 것이다.
- 객체지향 관점 - SW는 객체들의 모임 (현실세계와 동일한 부분은 이 관점만임)


#### 객체의 상태, 행동
- 객체는 상태를 가지며, 상태는 변경 가능
   - 상태가 변경되도 객체 자체의 아이덴티티는 유지
   - __현재 상태 = 과거 행동들의 결과의 요약__
- 객체의 상태는 해당 객체의 행동에 의해 변경됨 (반대로, 객체의 행동의 결과는 객체의 상태에 따라 결정되기도 함)
   - 행동의 순서가 결과에 영향을 미침 (행동은 stateless/멱등하지 않을 수 있음)
   - 행동의 결과는 상태를 이용해 표현 가능
- 객체는 `상태` (state), `행동` (behavior), `식별자` (identity)를 가진 실체

#### 상태와 프로퍼티

상태는 `프로퍼티`로 기술하며, 프로퍼티는 단순한 값인 `속성` (attribute)과 다른 객체로의 `링크`로 구성
- ex) 앨리스(객체)의 프로퍼티 - 키 (속성), 음료 (링크)

__상태는 객체가 행동을 통해 직접 변경하여야 함.__ 다른 객체의 상태는 그 객체의 행동을 통해 간접적으로 변경
- 상태가 변경되는 것은 행동의 사이드이펙트임 (function or expression is said to have a side effect if it modifies some state variable value(s) outside its local environment) <a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)" target="_blank">(wiki)</a>
- 객체의 행동은 상태를 변경시키며, 행동의 결과는 상태에 의존적
- `캡슐화` (encapsulation) - 객체가 외부에 노출하는 것은 행동뿐이며, 외부에서 객체에 접근할 수 있는 유일한 방법 역시 행동뿐이다
   - 객체의 자율성을 높이고 협력을 단순하고 유연하게 만듬


#### 식별자
- 객체를 구분하기 위한 프로퍼티
- 동등성 = 상태를 이용해 같은지 판단
- 동일성 = 특정 식별자를 기준으로 객체가 같은지 판단 (앨리스 키가 100에서 120으로 자라도, 앨리스는 앨리스)
- 식별자의 동의어: 참조 객체 (reference object), 엔티티 (entity)
   - 식별자가 아닌 프로퍼티: 값 객체 (value object)


객체의 특성 요약
- 객체는 상태를 가지며, 상태는 변경가능함
- 객체의 상태를 변경시키는 것은 행동임
   - 행동의 결과는 상태에 의존적이며, 상태를 이용해 서술가능
- 객체는 (시간에 따라 변하는) 상태에 관계없이 식별가능

#### 행동이 상태를 결정한다
- 디자인 중, 행동을 먼저 결정해야 함. 다른 객체와 협업하는 부분이 행동이기 때문 (역할을 책임지는 부분)
- 협업 부분이 정해지면 이에 따라 상태를 정해야 깔끔해지는 듯 

### 03 타입과 추상화

지하철 노선도 - 사실성 (역 간 거리)이 중요한 게 아니라 연결성, 순서가 중요 = 추상화

> 추상화 - 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.   
복잡성을 다루기 위해 추상화는 두 차원에서 이뤄진다  
- 첫 번째 차원은 __구체적인 사물들 간의 공통점을 취하고 차이점을 버리는 일반화를__ 통해 단순하게 만드는 것이다.
- 두 번째 차원은 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로서 단순하게 만드는 것이다  
모든 경우에 추상화의 목적은 복잡성을 이해하기 쉬운 수준으로 단순화하는 것이라는 점을 기억하라 - Kramer, Is abstraction the key to computing?

#### 개념 (concept)

`개념` - 공통점을 기반으로 객체들을 묶기 위한 그릇
- 개념이 객체적용됐을 때 객체를 개념의 `인스턴스`라고 함

개념의 3가지 관점
- 심볼 (개념의 이름)
- 내연 : 개념의 정의. 내연을 이용해 객체가 개념에 속하는지 확인가능
- 외연: 개념에 속하는 모든 객체

개념을 이용해 공통점을 가진 객체들을 분류할 수 있다는 아이디어는, OOP 패러다임이 복잡성을 극복하는 데 사용하는 가장 기본적인 인지 수단이다.
- 개념을 통해 객체를 분류하는 과정은, 추상화의 두 가지 차원을 모두 사용한다

#### 객체와 타입
- 타입의 정의는 개념과 완전히 동일 (...?)

객체의 타입 분류하기
- 객체는 행위에 따라 변할 수 있는 상태를 가진다. 앱 내부의 모든 객체의 상태를 모으면 결국 앱에서 관리해야 하는 전체 데이터이다
- __어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 행동이다__ 어떤 객체들이 동일한 행동을 수행한다면 그 객체들은 동일한 타입으로 분류될 수 있다.
   - 덕타이핑은 좀 다름. 덕타이핑엔 (동적 상속 + __타입 검사를 생략한다__ ) 는 의미가 있는 듯 
- 내부 표현 (상태)는 자율적임 - 객체의 내부 표현은 외부로부터 감춰지며, 이를 간접적으로 접근하는 것은 행동 뿐 (`캡슐화` encapsulation)
   - 내부 표현 방식이 다르기 때문에, 동일한 메시지를 다르게 처리할 수 있음 = 다형성에 의미를 부여
      - 동일한 행동을 하므로 동일한 메시지를 수신할 수 있어야 함 = 같은 타입에 속함
      - 음...뭔말인지 알긴 하겠는데. 위키의 다형성 정의는 또 다른데? (<a href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)" target="_blank">다른 타입에 대해 제공할 수 있는 단일 인터페이스</a>라고 함)
- 객체가 시스템상에서 가지는 의미는 행동에서 나오기 떄문에, 설계에서 행동을 먼저 생각하는 것이 맞음

#### 타입의 계층 - 일반화/추상화

트럼프 (슈퍼타입) \\(\leftarrowtriangle\\) 트럼프 인간 (서브타입)
- 서브타입 = 추가적인 기능, 좀 더 구체적
   - 외연은 슈퍼타입의 서브셋, 내연은 슈퍼셋 (ㄷㄷ)

정적 모델 - 시간에 따라 변하는 상태값에 관계없이, 추상화로 복잡도 제거
- 정작 개발할땐 컴파일타임에 동일타입인지 체크하는 용으로 쓰이는 듯?
- __정적인 모델은 클래스를 이용해 구현__
   - 클래스 \\(\neq\\) 타입. 클래스는 타입을 구현할 수 있는 여러 방법 중 하나
   
### 04 역할, 책임, 협력

책임 
 - 외부에 대해 해줄 수 있는 것 (doing) / 제공해 줄 수 있는 것 (knowing)으로 나뉨 = __책임은 객체의 공용 인터페이스가 됨__
 - 객체가 다른 객체에게 책임을 수행하도록 요청을 보내는 것을 `메시지 전송`이라고 한다
 - 보통 하나의 책임이 여러 메시지로 분해되는 것이 일반적

클래스
 - 객체지향의 정적인 측면을 표현
 - 객체를 표현하고 생성하기 위해 개발언어가 제공하는 구현 메커니즘 (일 뿐임. 클래스가 없는 OOP 언어도 있음

객체에게 책임을 할당하고 이를 구현하면 행동이 됨

패턴 = 특정 문제에 대한 역할, 책임, 협력의 best practice

TDD
- 실패하는 테스트를 작성 - 테스트를 통과하는 가장 간단한 코드를 작성 (이동안 중복 허용) - 리팩토링
- 설계 초기 팁: 객체가 이미 존재한다고 가정하고, 객체에게 __어떤 메시지를 보내야 하는지__ 먼저 생각하라고 충고
- TDD의 테스트 작성 = 책임을 수행할 객체가 메시지를 수신할 때 어떤 결과를 반환하고, 그 과정에서 어떻게 다른 객체와 협력할 것인지를 코드의 형태로 작성한 것

### 05 책임과 메시지
- 책임은 자율적이여야 함
   - 어떻게 (how)가 아니고 무엇(what)을 기술
   - 범위가 너무 좁으면 안됨 (...) = 너무 구체적인 메시지. 인터페이스를 추상적이게 구성해야 함
- 메시지는 how를 기술하지 않음. what만 기술

메시지를 수신한 객체가 실행 시간에 메서드를 선택할 수 있다 = 절차적 언어와 다른 점

객체의 외부와 내부는 메시지를 기준으로 분리됨

다형성은 송신자와 수신자 간의 객체 타엡이 대한 결합도를 메시지에 대한 결합도로 낮춤으로서 달성됨 (재사용성, 유연한 협력)

OOP 어플리케이션은 클래스로 만들어지지만 메시지로 정의됨

객체 인터페이스
- 인터페이스의 사용법만 알면 내부 구조를 몰라도 상호작용 가능
- 인터페이스가 변경되지 않는 한, 협력에는 아무런 영향이 없어야 함
- 메시지가 인터페이스를 결정 (반대가 아님)
- 인터페이스의 노출은 최소화해야 함 (N^(N+1)/2 )

### 06 객체 지도

> 다시 한번 강조하지만 SW객체는 현실 객체에 대한 추상화가 아니다. ... SW객체를 창조하기 위해 우리가 은유해야 하는 대상은 바로 도메인 모델이다.

시스템의 기능 vs 구조
- 기능 중심 설계: 기능 요구사항은 계속 바뀜 (불안정)
- 목적에 맞는 좋은 객체 구조라면, 변경에 열려 있음

기능을 수집/표현하기 위한 기법 = __유즈케이스 모델링__  
구조를 수집하고 표현하기 위한 기법 = __도메인 모델링__

#### 도메인 모델링
- 도메인: 사용자가 프로그램을 사용하는 분야 (개발의 대상이 되는 분야가 아니고, 사용자 관점임)
- 모델: 지식을 추상화, 단순화한 결과
- 도메인 모델 = 'SW가 목적하는 영역 내의 개념, 개념간 관계, 규칙/제약 등을 추상화한 결과'
- OOP는 도메인 모델을 구현하기 제일 좋은 framework임 - 클래스로 추상화된 타입 구현, 동적인 시스템을 정적 모델로 표현
- 도메인 모델을 사용하는 이유
  1. 도메인 모델은 사용자가 도메인(=현실의 문제)을 바라보는 관점을 담고 있기 때문
  2. 도메인 모델의 구조는 표면상의 기능보다 본질적임 = 안정적이고 변화가 적음

#### 유즈케이스 모델링
`유즈케이스 모델링` = 시스템의 기능적 요구사항을 사용자의 목표라는 문맥을 중심으로 묶기 위한 정리 기법
- 시스템의 외부 관점만을 (의도적으로) 표현
- 내부 구조, 실행 메커니즘, 객체 모델 구조에 대한 정보를 의도적으로 생략 - 유즈케이스 모델링을 통해 해당 항목들에 대한 힌트정도는 얻을 수 있지만 자동 변환 등은 불가능

#### 재료 합치기 = 도메인 + 유즈케이스
변경에 유연한 SW 만들기 = 유즈케이스에 정리된 시스템 기능을 도메인 모델을 기반으로 한 객체들의 책임으로 분리해야 함
- 시스템 객체가 수행해야 하는 책임 = 시스템 내부 객체들의 (자율적인) 협력으로 구성
  - 어떤 객체를 선택할 것인가 = 도메인 모델을 추상화하는 객체!

### 부록 - 추상화 기법

- 객체들을 공통적인  특성을 기반으로 범주로 묶고 개념을 적용하는 것은, __범주라는 렌즈를 통해 세상을 바라보는 것과 유사하다.__
- 객체에 개념(의 내연)을 적용하는 과정을 분류라고 한다
- 객체지향에서 개념을 가르키는 표준 용어는 타입이다. 따라서 타입은 개념과 동의어이며 속성과 행위가 유사한 객체에 공통적으로 적용되는 관념/아이디어를 의미함
- 도메인을 분석하는 동안 (도중 식별된) 이름, 의미, 객체 집합을 이용해 개념을 정의할 수 있다
- 타입은 보통 클래스를 이용해 구현됨 (따라서 둘이 동일하지는 않음)
- 생물 분류 체계 - __계층적__
   - 슈퍼타입을 공유한다는 것 만으로, 많은 특성 유추 가능 (ex - 포유류 = 젖을 먹음)
- OOP에서 계층 구현
   1. 슈퍼타입 - 서브타입 (is-a)
   2. has-a (composition): 객체간의 관계를 잘 설정할 경우, 복잡함을 객체 단위로 감출 수 있음. 이 경우 추상화 (계층구조 구현)와 캡슐화 (복잡함 감추기) 동시에 적용
- 서브타이핑 vs 서브클래싱: 슈퍼클래스를 완전히 대체가능하면 서브타이핑, 아니면 서브클래싱. 서브클래싱의 경우 메시지 처리 불가 - 슈퍼클래스로 역순으로 올라감 (= 클래스 간 `위임` delegation)
- 클래스만으로 계층구조 표현이 어려운 경우 = 클래스를 묶은 모듈도 상위에 활용가능

## Growing object-oriented software, guided by tests
- ㅁ
