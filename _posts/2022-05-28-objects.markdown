---
layout: post
title:  "Objects - 코드로 이해하는 객체지향 설계"
date:   2022-05-28 08:00:05 +0800
categories: coding
use_math: true
tags: coding
---

주당 100페이지 스터디 ㄷㄷ

### Intro, Chap1
- 어떤 프로그래밍 패러다임을 사용하느냐에 따라 문제를 바라보는 방식과 코드 작성방법이 달라짐
  - 코드와 페러다임은 분리불가능
- 과학 (지동설 vs 천동설)과 달리 개발에서는 여러 패러다임이 공존가능. C++ = 절차형 + 객체지향
- 설계/유지보수를 이야기할 때 이론중심적인것은 적절하지 않다 (아직 역사가 짧아서 이론도 없고, dominant한 이론도 없음) - 코드 그 자체가 제일 유용
  - 결국 유지보수를 직접 해보고 수정해서 배포해 봐야 아는 것 아닌가...경험이 없으면 이론보단 코드라도 봐라~ 정도로?

> SW 모듈의 목적 - 실행 중 제대로 동작하는 것, 변경에 열린 것, 읽기 쉬워야 하는 것

예제1
- 내가 코드 읽으면서 생각했던 것 - 단순 wrapper클래스가 너무 많다, 객체를 사용하려면 알아야 하는 가정이 쓸데없이 너무 많다
- 객체 사이의 의존성이 높다 = dependency가 높다. 설계의 목표는 결합도를 낮춰 변경이 용이한 설계를 만드는 것
- 객체의 자율성을 높이면 의존성을 낮출 수 있음 ( = `캡슐화`, 자연적으로 변경범위도 줄어듬)
- TicketOffice가 TicketSeller, Ticket, Bag 클래스에 다 접근하던 걸, wrapper 클래스 (티켓셀러 등)에 자율성을 줘서 방지 
  - 인터페이스에만 의존하게 (근데 이전에도 인터페이스만 의존하고 있긴 했음. 넘 많이 의존해서 그렇지..)
- __객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 결합도를 낮추고 변경에 열린 코드를 작성하기 위한 가장 기본적인 설계원칙이다 (캡슐화 활용)__

`절차적 프로그래밍` - 프로세스와 데이터를 별도 모듈에 위치시키는 방법
- 객체들을 가지고 절차적 프로그래밍을 수행할 수는 있지만, 이러면 보통 객체들이 수동적으로 되어 버림 (절차 수행에 필요한 데이터만 갖고 있게 됨)
- 코드 변경의 범위를 제한시키기도 어려움 (큰 절차 하나가 모든 것을 다 처리하는 경우)
  - 함수로 모듈화하면 안되나?

`객체지향 프로그래밍` - 데이터와 프로세스가 동일한 모듈에 위치하게 설계
- 확실히 자율화시키긴 쉬울 듯

> 설계를 어렵게 만드는 것은 의존성. 해결방법 = 캡슐화 (자율성 확보)를 통해 불필요한 의존성 제거 -> `응집도` 높은 객체들의 공동체 생성


기타
- 이렇게 자율화하다보면, 실생활에선 수동적인 것들도 자율적인 객체로 구현될 때가 있음 -> `의인화` (능동적이고 자율적인 객체로 SW객체를 설계하는 원칙)
- 설계를 구현 (+개발 패러다임)과 따로 이야기하는 것은 불가능
- 변경에 열려야 하는 이유
  1. 요구사항이 항상 변하기 떄문 (현실의 변화, 첨에 불완전)
  2. 버그 -> 열린설계 + 테스트(!)
- 변경가능한 코드란 이해하기 쉬운 코드다 (iif관계인 듯)



### Chap 2 객체지향 프로그래밍
- 화요일까지 ㄱㄱ