---
layout: post
title:  "Objects - 코드로 이해하는 객체지향 설계 Chap1, 2, 3"
date:   2022-05-31 08:00:05 +0800
categories: coding
use_math: true
tags: coding
---

주당 100페이지 스터디 ㄷㄷ

### Intro, Chap1
- 어떤 프로그래밍 패러다임을 사용하느냐에 따라 문제를 바라보는 방식과 코드 작성방법이 달라짐
  - 코드와 페러다임은 분리불가능
- 과학 (지동설 vs 천동설)과 달리 개발에서는 여러 패러다임이 공존가능. C++ = 절차형 + 객체지향
- 설계/유지보수를 이야기할 때 이론중심적인것은 적절하지 않다 (아직 역사가 짧아서 이론도 없고, dominant한 이론도 없음) - 코드 그 자체가 제일 유용
  - 결국 유지보수를 직접 해보고 수정해서 배포해 봐야 아는 것 아닌가...경험이 없으면 이론보단 코드라도 봐라~ 정도로?

> SW 모듈의 목적 - 실행 중 제대로 동작하는 것, 변경에 열린 것, 읽기 쉬워야 하는 것

예제1
- 내가 코드 읽으면서 생각했던 것 - 단순 wrapper클래스가 너무 많다, 객체를 사용하려면 알아야 하는 가정이 쓸데없이 너무 많다
- 객체 사이의 의존성이 높다 = dependency가 높다. 설계의 목표는 결합도를 낮춰 변경이 용이한 설계를 만드는 것
- 객체의 자율성을 높이면 의존성을 낮출 수 있음 ( = `캡슐화`, 자연적으로 변경범위도 줄어듬)
- TicketOffice가 TicketSeller, Ticket, Bag 클래스에 다 접근하던 걸, wrapper 클래스 (티켓셀러 등)에 자율성을 줘서 방지 
  - 인터페이스에만 의존하게 (근데 이전에도 인터페이스만 의존하고 있긴 했음. 넘 많이 의존해서 그렇지..)
- __객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 결합도를 낮추고 변경에 열린 코드를 작성하기 위한 가장 기본적인 설계원칙이다 (캡슐화 활용)__

`절차적 프로그래밍` - 프로세스와 데이터를 별도 모듈에 위치시키는 방법
- 객체들을 가지고 절차적 프로그래밍을 수행할 수는 있지만, 이러면 보통 객체들이 수동적으로 되어 버림 (절차 수행에 필요한 데이터만 갖고 있게 됨)
- 코드 변경의 범위를 제한시키기도 어려움 (큰 절차 하나가 모든 것을 다 처리하는 경우)
  - 함수로 모듈화하면 안되나?

`객체지향 프로그래밍` - 데이터와 프로세스가 동일한 모듈에 위치하게 설계
- 확실히 자율화시키긴 쉬울 듯

> 설계를 어렵게 만드는 것은 의존성. 해결방법 = 캡슐화 (자율성 확보)를 통해 불필요한 의존성 제거 -> `응집도` 높은 객체들의 공동체 생성


기타
- 이렇게 자율화하다보면, 실생활에선 수동적인 것들도 자율적인 객체로 구현될 때가 있음 -> `의인화` (능동적이고 자율적인 객체로 SW객체를 설계하는 원칙)
- 설계를 구현 (+개발 패러다임)과 따로 이야기하는 것은 불가능
- 변경에 열려야 하는 이유
  1. 요구사항이 항상 변하기 떄문 (현실의 변화, 첨에 불완전)
  2. 버그 -> 열린설계 + 테스트(!)
- 변경가능한 코드란 이해하기 쉬운 코드다 (iif관계인 듯)



### Chap 2 객체지향 프로그래밍
- 영화: 영화 자체 (=지적재산권)
- 상영: 실제로 관객들이 관람하는 시간 포함. 영화:상영 = 1:N
- 할인 = 할인 조건 + 할인 정책
  - 할인 조건 = 순서 조건 (조조상영, 그날의 10번째) or 기간 조건 (from~to), 영화와 1:N
  - 할인 정책 = 금액 할인 (절대값 할인) or 비율 할인 (10%) 중 택 1, 영화와 1:1


#### 협력, 객체, 클래스
- 객체지향은 객체를 지향하는 것 - 클래스가 주가 아님
- 객체는 협력하는 공동체의 일원
- `도메인`: 문제해결을 위해 사용자가 프로그래밍을 사용하는 분야
  - 객체지향 페러다임이 강력한 이유 = 요구사항 분석부터 마무리 구현까지, 객체라는 동일한 추상화 기법을 사용가능 (추상화 기법이 바뀌는 경우도 있나?)
  - 객체지향에서는 클래스로 도메인의 개념들을 구현
  - 클래스는 내부와 외부로 구분, 훌륭한 클래스 설계의 핵심 = 어디를 공개하고 어디를 감출지 결정하는 것 -> __경계의 명확성이 객체의 자율성을 보장__

#### 자율적인 객체
- 객체는 상태(state)와 행동(behavior)를 같이 가지는 복합적인 존재 (=캡슐화, 객체지향의 특징 (절차지향은 둘이 따로 감))
  - `캡슐화`: 데이터와 기능을 객체 내부로 함께 묶는 것
  - 캡슐화를 위해 많은 프로그렘은 public, private 등의 `접근 수정자` (access modifier) 제공
- 객체는 자율적인 존재
  - 접근 통제는 자율적인 존재를 만들기 위한 것
  - 객체가 자율적이다 = 자신의 __상태를 스스로 관리하고__ 스스로의 결정에 따라 행동
- 캡슐화와 접근 제어는 객체를 두 부분으로 나눔
  - `퍼블릭 인터페이스`: 외부에서 접근 가능한 부분
  - `구현 (implementation)`: 내부에서만 접근 가능
  - seperation of interface and implementation: 객체지향의 핵심 원칙
    - implementation hiding - 인터페이스만 외부에 내 주면, 구현은 인터페이스를 변경하지 않는 한 맘대로 변경가능
- 설계가 필요한 이유는 변경을 관리하기 위해서임
  - OOP는 객체간 의존성을 관리해서 변경의 파급효과를 제어가능 - 접근지정자 등으로 

#### 메시지, 메서드
- 객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 `요청`할 수 있음
- 요청을 받은 객체는 자율적인 방법(=`메서드`)에 따라 요청을 처리하고 `응답`을 전달
- 객체가 다른 객체와 상호작용하는 방법은 메시지를 전송하는 것 뿐
- 메시지와 메서드의 구분에서부터 `다형성`의 개념이 출발
- 결국 A가 B의 메서드를 호출한다 = A가 B에게 메시지를 전송한다
- 인터페이스는 객체가 이해할 수 있는 메세지의 목록을 정의

#### 할인 요금 구하기 - 추상화
- 할인 정책은 금액/비율 할인 정책으로 구분됨 - 중복되는 부분이 많음
- -> 할인정책 추상클래스를 만들고, 내부 calcDiscount함수에서 getDiscount 추상메소드를 이용해서 요금 계산 -> 템플릿메소드??? 벌써 다 까먹은 듯...
- `Template Method`: 부모클래스에 기본적인 알고리즘 템플릿 구현 (with 추상메소드), 자식에게 추상메소드 구현
- 오버라이딩 = 부모클래스의 시그니처가 동일한 함수 재정의
- 오버로딩 = 다른 시그니처, 다른 파라미터
- 생성자의 파라미터 목록으로 초기화에 필요한 정보전달 강제 -> 원하는 상태를 가진 객체의 생성을 보장 (다른 객체B와의 1:N, 객체 C와의 1:1 관계 등 보장)

#### 상속, 다형성, 
- `의존성`이 있다 - 다른 클래스의 메서드 호출 / 내부구조 등을 알아야 실행되는 부분이 있다
- 클래스 사이의 의존성 (인터페이스, 코드 간)과 객체 사이의 의존성 (실행 시점)은 동일하지 않을 수 있음 = 확장 가능한 OOP설계가 가지는 특징
  - 코드를 이해하기는 어려워지나 (읽은 것 대로 실행되지는 않으므로), 코드가 변경에 열리게 됨 - __트레이드오프가 분명히 존재__
- 설계가 유연해짐 -> 코드이해/디버깅은 어려워짐 (and vice versa)
- 차이의 의한 프로그래밍 (`programming by difference`) - 상속받고 일부분만 수정
- `upcasting`: 자식클래스가 부모클래스를 대신
- 다형성 = 동일한 인터페이스를 가진 (동일한 메시지를 이해할 수 있는) 클래스들끼리에서, 메시지를 수신했을 때 객체의 타임에 따라 다르게 응답할 수 있는 능력
  - 동적(지연)바인딩 = 런타임에 바인딩. OOP언어의 메커니즘
  - 정적(초기)바인딩 = 컴파일타임에. 절차지향적
- 구현 상속 = 코드 재사용만을 위한 상속, 인터페이스 상속 = 다형성을 위한 상속 (이런 구분이 유의미한가? 첫째를 조심하란 의미인가..)
- 추상클래스끼리만 의존성을 보면, 상위 정책을 쉽고 간단하게 표현 가능
  - = 기본적인 앱의 협력 흐름을 기술한다는 것

#### 코드 재사용
- 코드 재사용을 위해서는 (보통) 상속보다는 합성이 더 좋다
  - __상속은 캡슐화를 위반__ - 자식클래스는 부모의 내부에 대해 잘 알게 됨
  - __상속의 남발은 설계를 유연하지 않게 만듬__ (컴파일 타임에 상혹관계 결정)
- 합성도 인터페이스를 알긴 할지만, 상속보다는 유연함 (런타임에 덕타이핑 등으로 결합)
- `합성`: 인터페이스에 정의된 메시지를 통해서만 코드를 재사용
- 합성은 구현을 캡슐화하고, 런타임에 교체 가능 (상속의 문제점 2개 해결)
  - but 다형성을 이용하기는 어려움. 둘 다 같이 써야 함


### Chap 3 역할, 책임, 협력
- 다형성은 지연 바인딩이라는 메커니즘을 사용해 구현됨
- 상속은 코드를 재사용하는 가장 널리 알려진 방법이지만 캡슐화 측면에서 합성이 더 좋음
- 객체지향 설계의 핵심은 협력을 구성하기 위해 적절한 객체에 적절한 책임을 할당하는 과정 - 클래스/상속은 이것이 어느정도 자리잡은 뒤 사용가능한 구현 메커니즘일 뿐
- `협력`: 객체들이 앱의 기능을 구현하기 위해 수행하는 상호작용
  - `책임`: 이 때 객체들이 수행하는 각 로직
- `역할`: 책임의 집합 (객체에게 정의되는 개념)
- `메시지 전송`: 객체간 협력을 위한 유일한 방법

객체가 자율적이다 = 자신의 상태를 직접 관리하고 스스로의 결정에 따라 행동 -> 캡슐화가 일단 제일 필요
- 외부의 도움이 필요한 경우 메시지 전송


#### 협력 = 문맥
앱에 객체가 필요하다면 그 이유는 단 하나 - 해당 객체가 어떤 협력에 참여하고 있기 떄문
- 객체의 행동을 결정하는 것은 객체가 참여하는 협력
- 객체의 상태를 결정하는 것은 행동 - 객체의 상태는 행동을 수행하는 데 필요한 정보가 무엇인지로 결정됨
결국 협력 -> 행동 -> 상태 순으로 결정되므로, 협력이 시작 - __협력은 객체를 설계하는 데 필요한 문멕(context)을 제공__

#### 책임
`책임`: 객체단위로 부여되는, 객체가 유지해야 하는 정보 + 수행할 수 있는 행동
- __하는 것과 아는 것으로 구분__
  - 하는 것: 객체생성, 계산, 다른 객체 트리거링 / 조절 (메시지 보내기?)
  - 아는 것: 다른 객체의 구조를 아는 것, 자신이 뭘 계산할 수 있을 지 아는 것, private data에 대해 아는 것 등
- 일반적으로 책임 != 메시지
  - 책임은 좀 더 추상적, 책임:메시지가 1:N으로 될 수도 있음. 심지어 일부 책임은 여러 객체가 협력해야 하기도 함
- 설계 초기에 책임을 할당할 후보는 객체일 수도 있고, 역할일 수도 있다 (?!)
- 협력을 설계하는 출발점 - 시스템의 전체기능을 하나의 책임으로 놓고, 이를 분해 + (충분히 작아졌을 때) 객체들에게 할당
- 객체가 책임을 수행하게 (트리거링하는) 유일한 방법은 메시지를 전송하는 것 -> 책임을 객체에 할당한다는 것은 객체가 관련해서 수신할 메시지의 이름을 결정하는 것과 동일
  - 이 때 해당 책임에 대해 가장 잘 아는 객체에게 줘야 함 = 정보 전문가 패턴 (`Information Expert`) (...)
  - 응집/결합도 관점에서 정보전문가말고 다른 객체에게 책임을 할당하는 게 좋은 경우도 있음
- `이렇게 결정된 메시지가 객체의 퍼블릭 인터페이스를 구성`

`책임 주도 설계`: 책임을 찾고/분해하고, 책임을 수행할 적절한 객체를 찾아 책임을 할당

#### 메시지가 객체를 결정한다 (84p)
- 위에서 메시지가 객체를 선택했음. 그 이유
  - 객체가 최소한의 인터페이스를 가질 수 있음 (?)
  - 객체가 무엇을 하는지에 집중 -> 추상적인 인터페이스를 만들 수 있음 (?)

#### 역할
- 객체가 특정 협력 안에서 수행하는 책임의 집합
- 개념 도입 이유 - 협력을 역할로 분할해 재사용성 / 유연성 증가
  - `역할은 다른 것으로 교체할 수 있는 책임의 집합`
    - 역할이른 프로그램이 돌 때, 적절한 객체로 메워 넣을 수 있는 하나의 슬롯 ...
      - 보통 역할:객체는 1:N일 수도 있고 (1개 역할을 여러 객체가 수행가능), N:1일 수도 (SRP위반!)
    - 추상화 + 다형성 등으로 교체
      역할을 객체의 추상화로 볼 수도 있음
    - 요점은 동일한 책임을 수행하는 역할을 기반으로, 2개 이상 다수의 협력을 하나로 통합 가능
