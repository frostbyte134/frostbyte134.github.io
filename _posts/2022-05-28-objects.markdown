---
layout: post
title:  "Objects - 코드로 이해하는 객체지향 설계 Chap1, 2, 3"
date:   2022-05-28 08:00:05 +0800
categories: coding
use_math: true
tags: coding
---

주당 100페이지 스터디 ㄷㄷ

### Intro, Chap1
- 어떤 프로그래밍 패러다임을 사용하느냐에 따라 문제를 바라보는 방식과 코드 작성방법이 달라짐
  - 코드와 페러다임은 분리불가능
- 과학 (지동설 vs 천동설)과 달리 개발에서는 여러 패러다임이 공존가능. C++ = 절차형 + 객체지향
- 설계/유지보수를 이야기할 때 이론중심적인것은 적절하지 않다 (아직 역사가 짧아서 이론도 없고, dominant한 이론도 없음) - 코드 그 자체가 제일 유용
  - 결국 유지보수를 직접 해보고 수정해서 배포해 봐야 아는 것 아닌가...경험이 없으면 이론보단 코드라도 봐라~ 정도로?

> SW 모듈의 목적 - 실행 중 제대로 동작하는 것, 변경에 열린 것, 읽기 쉬워야 하는 것

예제1
- 내가 코드 읽으면서 생각했던 것 - 단순 wrapper클래스가 너무 많다, 객체를 사용하려면 알아야 하는 가정이 쓸데없이 너무 많다
- 객체 사이의 의존성이 높다 = dependency가 높다. 설계의 목표는 결합도를 낮춰 변경이 용이한 설계를 만드는 것
- 객체의 자율성을 높이면 의존성을 낮출 수 있음 ( = `캡슐화`, 자연적으로 변경범위도 줄어듬)
- TicketOffice가 TicketSeller, Ticket, Bag 클래스에 다 접근하던 걸, wrapper 클래스 (티켓셀러 등)에 자율성을 줘서 방지 
  - 인터페이스에만 의존하게 (근데 이전에도 인터페이스만 의존하고 있긴 했음. 넘 많이 의존해서 그렇지..)
- __객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 결합도를 낮추고 변경에 열린 코드를 작성하기 위한 가장 기본적인 설계원칙이다 (캡슐화 활용)__

`절차적 프로그래밍` - 프로세스와 데이터를 별도 모듈에 위치시키는 방법
- 객체들을 가지고 절차적 프로그래밍을 수행할 수는 있지만, 이러면 보통 객체들이 수동적으로 되어 버림 (절차 수행에 필요한 데이터만 갖고 있게 됨)
- 코드 변경의 범위를 제한시키기도 어려움 (큰 절차 하나가 모든 것을 다 처리하는 경우)
  - 함수로 모듈화하면 안되나?

`객체지향 프로그래밍` - 데이터와 프로세스가 동일한 모듈에 위치하게 설계
- 확실히 자율화시키긴 쉬울 듯

> 설계를 어렵게 만드는 것은 의존성. 해결방법 = 캡슐화 (자율성 확보)를 통해 불필요한 의존성 제거 -> `응집도` 높은 객체들의 공동체 생성


기타
- 이렇게 자율화하다보면, 실생활에선 수동적인 것들도 자율적인 객체로 구현될 때가 있음 -> `의인화` (능동적이고 자율적인 객체로 SW객체를 설계하는 원칙)
- 설계를 구현 (+개발 패러다임)과 따로 이야기하는 것은 불가능
- 변경에 열려야 하는 이유
  1. 요구사항이 항상 변하기 떄문 (현실의 변화, 첨에 불완전)
  2. 버그 -> 열린설계 + 테스트(!)
- 변경가능한 코드란 이해하기 쉬운 코드다 (iif관계인 듯)



### Chap 2 객체지향 프로그래밍
- 영화: 영화 자체 (=지적재산권)
- 상영: 실제로 관객들이 관람하는 시간 포함. 영화:상영 = 1:N
- 할인 = 할인 조건 + 할인 정책
  - 할인 조건 = 순서 조건 (조조상영, 그날의 10번째) or 기간 조건 (from~to), 영화와 1:N
  - 할인 정책 = 금액 할인 (절대값 할인) or 비율 할인 (10%) 중 택 1, 영화와 1:1


#### 협력, 객체, 클래스
- 객체지향은 객체를 지향하는 것 - 클래스가 주가 아님
- 객체는 협력하는 공동체의 일원
- `도메인`: 문제해결을 위해 사용자가 프로그래밍을 사용하는 분야
  - 객체지향 페러다임이 강력한 이유 = 요구사항 분석부터 마무리 구현까지, 객체라는 동일한 추상화 기법을 사용가능 (추상화 기법이 바뀌는 경우도 있나?)
  - 객체지향에서는 클래스로 도메인의 개념들을 구현
  - 클래스는 내부와 외부로 구분, 훌륭한 클래스 설계의 핵심 = 어디를 공개하고 어디를 감출지 결정하는 것 -> __경계의 명확성이 객체의 자율성을 보장__

#### 자율적인 객체
- 객체는 상태(state)와 행동(behavior)를 같이 가지는 복합적인 존재 (=캡슐화, 객체지향의 특징 (절차지향은 둘이 따로 감))
  - `캡슐화`: 데이터와 기능을 객체 내부로 함께 묶는 것
  - 캡슐화를 위해 많은 프로그렘은 public, private 등의 `접근 수정자` (access modifier) 제공
- 객체는 자율적인 존재
  - 접근 통제는 자율적인 존재를 만들기 위한 것
- 캡슐화와 접근 제어는 객체를 두 부분으로 나눔
  - `퍼블릭 인터페이스`: 외부에서 접근 가능한 부분
  - `구현 (implementation)`: 내부에서만 접근 가능
  - seperation of interface and implementation: 객체지향의 핵심 원칙
    - implementation hiding - 인터페이스만 외부에 내 주면, 구현은 인터페이스를 변경하지 않는 한 맘대로 변경가능
- 설계가 필요한 이유는 변경을 관리하기 위해서임
  - OOP는 객체간 의존성을 관리해서 변경의 파급효과를 제어가능 - 접근지정자 등으로 

#### 메시지, 메서드
- 객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 `요청`할 수 있음
- 요청을 받은 객체는 자율적인 방법(=`메서드`)에 따라 요청을 처리하고 `응답`을 전달
- 객체가 다른 객체와 상호작용하는 방법은 메시지를 전송하는 것 뿐
- 메시지와 메서드의 구분에서부터 `다형성`의 개념이 출발
- 결국 A가 B의 메서드를 호출한다 = A가 B에게 메시지를 전송한다
- 인터페이스는 객체가 이해할 수 있는 메세지의 목록을 정의

#### 할인 요금 구하기 - 추상화
- 할인 정책은 금액/비율 할인 정책으로 구분됨 - 중복되는 부분이 많음
- -> 할인정책 추상클래스를 만들고, 내부 calcDiscount함수에서 getDiscount 추상메소드를 이용해서 요금 계산 -> 템플릿메소드??? 벌써 다 까먹은 듯...
- `Template Method`: 부모클래스에 기본적인 알고리즘 템플릿 구현 (with 추상메소드), 자식에게 추상메소드 구현
- 오버라이딩 = 부모클래스의 시그니처가 동일한 함수 재정의
- 오버로딩 = 다른 시그니처, 다른 파라미터
- 생성자의 파라미터 목록으로 초기화에 필요한 정보전달 강제 -> 원하는 상태를 가진 객체의 생성을 보장 (다른 객체B와의 1:N, 객체 C와의 1:1 관계 등 보장)

#### 상속, 다형성, 
- `의존성`이 있다 - 다른 클래스의 메서드 호출 / 내부구조 등을 알아야 실행되는 부분이 있다
- 클래스 사이의 의존성 (인터페이스, 코드 간)과 객체 사이의 의존성 (실행 시점)은 동일하지 않을 수 있음 = 확장 가능한 OOP설계가 가지는 특징
  - 코드를 이해하기는 어려워지나 (읽은 것 대로 실행되지는 않으므로), 코드가 변경에 열리게 됨 - __트레이드오프가 분명히 존재__
- 설계가 유연해짐 -> 코드이해/디버깅은 어려워짐 (and vice versa)
- 차이의 의한 프로그래밍 (`programming by difference`) - 상속받고 일부분만 수정
- `upcasting`: 자식클래스가 부모클래스를 대신
- 다형성 = 동일한 인터페이스를 가진 (동일한 메시지를 이해할 수 있는) 클래스들끼리에서, 메시지를 수신했을 때 객체의 타임에 따라 다르게 응답할 수 있는 능력
  - 동적(지연)바인딩 = 런타임에 바인딩. OOP언어의 메커니즘
  - 정적(초기)바인딩 = 컴파일타임에. 절차지향적
- 구현 상속 = 코드 재사용만을 위한 상속, 인터페이스 상속 = 다형성을 위한 상속 (이런 구분이 유의미한가? 첫째를 조심하란 의미인가..)
- 추상클래스끼리만 의존성을 보면, 상위 정책을 쉽고 간단하게 표현 가능
  - = 기본적인 앱의 협력 흐름을 기술한다는 것

#### 코드 재사용
- 코드 재사용을 위해서는 (보통) 상속보다는 합성이 더 좋다
  - __상속은 캡슐화를 위반__ - 자식클래스는 부모의 내부에 대해 잘 알게 됨
  - __상속의 남발은 설계를 유연하지 않게 만듬__ (컴파일 타임에 상혹관계 결정)
- 합성도 인터페이스를 알긴 할지만, 상속보다는 유연함 (런타임에 덕타이핑 등으로 결합)
- `합성`: 인터페이스에 정의된 메시지를 통해서만 코드를 재사용
- 합성은 구현을 캡슐화하고, 런타임에 교체 가능 (상속의 문제점 2개 해결)
  - but 다형성을 이용하기는 어려움. 둘 다 같이 써야 함