---
layout: post
title:  "Objects - 코드로 이해하는 객체지향 설계 Chap13, 14, 15"
date:   2022-07-01 08:00:05 +0800
categories: coding
use_math: true
tags: coding
---


### Chap 13 서브클래싱, 서브타이핑 (타입계층)

상속의 용도
1. first and foremost - 타입 계층 구현  
  부모 = 자식의 일반화, 자식 = 부모의 추상화
2. 코드 재사용 - 결합도가 높은 코드가 되어 남용하면 좋지않음

결론 - 다형적인 객체 (동일한 메시지에 다르게 동작할 수 있는)를 구현하기 위해서는 __객체의 행동을 기반으로__ 타입 계층을 구성해야 함

`객체기반 프로그래밍` - 객체 (행동 + 데이터)는 지원하지만 상속 등에 의한 위임은 지원 X
`프로토타입 기반 언어` - 클래스가 없이 객체만 있음

#### 타입이란

일반적인 타입 = 사람이 인지하는 사물의 종류
- `심볼` symbol: 타입의 이름. e.g) 프로그래밍 언어
- `내연` intention: 타입의 정의. 타입에 속하는 `인스턴스`들의 공통 속성/행동. e.g) 컴퓨터에게 명령을 내리는 언어
- `외연` extention: 타입에 속하는 객체들의 집합. e.g.) 파이썬, Rust, go, C++, ..


프로그래밍 언어 관점의 타입 = __비트집합에 의미와 제약을 부여하기 위해 사용됨__
1. 타입에 수행될 수 있는 operation의 목록을 정의
2. 타입에 수행되는 오퍼레이션에 대해, 컨텍스트를 제공  
  ex) a + b -> a,b가 int일시와 a=str, b=int일시 컨텍스트가 다름 -> 이 컨텍스트를 타입이 제공


OOP 관점의 타입
- 프로그래밍 언어 타입 관점에서, 타입은 오퍼레이션의 집합
  - OOP에서 오퍼레이션의 집합 = 객체가 수신가능한 (퍼블릭) 메시지의 집합 = `퍼블릭 인터페이스`
  - 따라서 OOP에서 타입을 정의한다 = 퍼블릭 인터페이스를 정의한다
  - 동일한 메시지를 수신한다 = 타입이 같다
  - 상태가 동일해도 수신가능한 메시지가 다르다 = 타입이 다르다
    - 객체에겐 상태보다 행동이 중요. 객체를 바라볼 땐 항상 외부에 제공하는 상태에 초점을 둬야지, 내부 상테에 초점을 두면 안됨

#### 타입 계층
[Martin98]
- 일반화: 서로 다른 타입을 완전이 포함하거나 내포하는 새 타입을 식별하는 행위
- 특수화: 다른 타입 안에 포함되는 타입을 식별하는 행위
- __OOP에서 타입간의 관계 정의의 기준은 퍼블릭 인터페이스임__
  - A가 B의 일반화 = B의 퍼블릭 인터페이스가 A의 퍼블릭 인터페이스의 슈퍼셋

서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다 (LISKOV?). ... 상속과 다형성의 관계를 이해하기 위한 출발점이다.


#### 서브클래싱, 서브타이핑

언제 상속을 사용해야 하는가?
- (자연어적으로) is-a관계를 모델링하는가? -> 보조적 (penguin is-a bird)
  - 코드 이해에 있어서는 의미가 있긴 하나, 결국 "클라이언트의 입장에서 본" 퍼블릭 인터페이스가 더 중요
  - 자연어적 is-a관계는 이름을 지을 떄 활용하면 좋음 (ㅎㅎ)
  - 어휘적 정의가 아니라 기대되는 행동에 따라 타입 계층을 수정해야 한다
- 클라이언트 입장에서, 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?
  - `행동 호환성`을 만족시키는가로 판단해야 함
  - 타입의 이름간 연관성이 있더라도 (언어적으로 is-a를 만족시키더라도) "클라이언트 관점에서" 행동에 연관성이 없으면 상속을 사용하지 말아야 함
  - 클라이언트가 두 타입이 동일하게 행동할 거라고 (같은 메시지를 받을 거라고 = 같은 퍼블릭 인터페이스를 가질 거라고) 기대한다면 두 타입을 같은 계층으로 묶어도 됨
  - penguin 예제 - 타입을 나누지 않고 수정해 보기
    1. penguin에서 fly를 오버라이딩 및 pass - 클라이언트가 bird객체가 fly하기를 기대하는데 이를 만족 못함
    2. penguin에서 fly를 오버라이딩 및 raise exception - 클라이언트와 협의가 되면 되긴 하는데, 깔끔하지 못함
    3. 클라이언트가 instanceof로 구분해서 알잘딱하게 사용 - 새 타입을 추가할 때 마다 if-instanceof문이 추가될 가능서잉 있음 - OCP 위반
  - 결국 해결방법은 클라이언트에 따라 인터페이스를 분리하는 것
    - penguin에서 bird의 코드를 재사용하고 싶다면 합성 (+의존성주입)이 그나마 나음
  - "이처럼 인터페이스를 클라이언트의 기대에 따라 분리함으로서 변경에 의해 영향을 제어하는 설계 원칙을 ISP라고 함" `ISP - Interface Segregation Principle`
    - > 이 원칙은 비대한 인터페이스의 단점을 해결한다. 비대한 인터페이스를 가지는 클래스는 응집성이 없는 인터페이스를 가지는 클래스다. 즉, 이런 클래스의 인터페이스는 메서드의 그룹으로 분리될 수 있고, 각 그룹은 각기 다른 클라이언트 집합을 지원한다 [Martin02]
  - 결국, 클라이언트가 달라지면 (이상적인) 설계도 달라짐

`서브클래싱` - 구현을 재사용하려는 상속. bad (= `클래스 상속`)
`서브타이핑` - 계층 구성을 위한 상속 (= `인터페이스 상속`)


#### 리스코프 치환 원칙 (LSP, Liskov Substitution Principle)

서브타입은 기반 타입을 대체가능해야 한다
- 클라이언트가 차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다 [Hunt99]
  - 당연히 결과는 달라도 됨. 컨텍스트를 외부에서 주입해 줄 때, 어떤 타입인지 몰라도 __사용가능한가가__ 의미있음.
- = __클라이언트 입장에서__ is-a 관점일 때 성립 (자연어적 관점이 아니라)
- LSP를 위반하면 서브타이핑이 아니라 서브클래싱 관계

정사각형 is-a 직사각형
- 언어적으로는 말이 되나, 클라이언트는 직사각형을 쓸 때 width=height의 가정을 갖고 있지 않음 - LSP위반 - 서브클래싱 관계

RECAP: 의존성 역전 (DIP) - 구체클레스가 추상클레스에 의존해야

> 일반적으로 LSP는 잠재적인 OCP이다 [Martin02]

클래스 상속은 타입계층을 구현하는 방법 중 하나일 뿐
- 상속 예시를 많이 드는 이유 = 구현상속 등의 나쁜 예제가 많기 때문
- 프로토타입 언어에서도 LSP는 지켜져야 함

#### 계약에 의한 설계

`계약에 의한 설계`: 클라이언트와 서버 사이의 협력을 의무 (obligation)와 이익(benefit)으로 표현
- 사전조건 precondition: 클라이언트가 메서드를 실행하기 위해 만족시켜야 하는 조건
- 사후조건 postcondition: 메서드가 실행된 이후 서버가 보장해야 하는 조건
- 클래스 불변식 class invariant: 실행 전후로 지속적으로 보장되어야 하는 조건. 모든 객체들에 해당

LSP와 계약에 의한 설계
- 서브타입이 LSP을 만족하기 위해서는, 서브타입도 클라이언트와 슈퍼타입 간에 체결된 계약을 준수해야 한다
- 계약에 의한 설계에 의하면, 협력중인 클라이언트와 슈퍼타입 객체는 모종의 계약을 맺고 있음
  - LSP says: 서브타입도 이 계약을 잘 지켜서 클라이언트가 모르게 교체할 수 있어야

모든 서브클래스가 서브타입은 아니다 - LSP못지킬시, 같은 계약을 준수하지 못했을 시 서브클래스이나 서브타입이 아님

서브클래스가 서브타입이 되기 위한 방법
- 서브타입에 더 강한 사전조건을 정의할 수 없다
  - 클라이언트가 지켜야 하는 조건이 더 강해짐 - 모르고 쓸 수 없음
- 서브타입에 슈퍼타입과 같거나 더 약한 사전조건은 정의할 수 있다
  - 기존 협력에 영향을 주지 않는다? 기존보다 사전조건을 통과하는 경우가 더 많아질 거긴 한데 아직 협력의 결과가 나온 건 아니니까 ㅇㅋ!
  - 모르고 쓸 수 있다는 게 중요한 듯. 클라이언트는 기존 조건만 만족하게 짜면 문제는 없으니까
- 서브타입에 더 강한 사후조건을 정의할 수 있다
  - 서브타입의 결과물이 더 강한 조건을 만족한다 -> 기존의 조건도 만족 -> 클라이언트 입장에선 노상관
  - 반대는 불가능


### Chap 14

객체들의 협력 구조가 다르면 코드이해도 어렵고 변경도 힘듬
- OOP의 장점은 설계를 재사용가능하다는 것 - but __아무거나 재사용할 순 없음__
- 재사용을 위해서는 일관적인 객체 간의 협력이 필요
  - 변하지 않는 부분 + 추상화 된 부분은 재사용 가능!
- 가능하면 유사한 기능을 구현하기 위해 유사한 협력패턴을 사용하자


변경을 캡슐화하기 (협력을 일관성있게 만들기 위해)
1. 변하는 개념을 변하지 않는 개념으로부터 분리 (식별이 쉽진 않음 ㅎㅎ)
2. 변하는 개념을 캡슐화
  - 이걸로 타입 계층 구성
3. 변하지 않는 부분에 변하는 부분을 합성 + 추상화에 의존

절차지향에서 변경을 처리하는 전통적 방법 = if-else
- OOP는 다형성을 이용한 객체 간 협력 (concrete implemenation은 모르지만 넘겨주기)로 처리

이걸 위해서는 큰 클래스 (다중 if-else로 떡칠된)를 쪼개야 함
- 잘 쪼개는 방법 = SRP (클래스는 1개의 이유에 의해 변경돼야 하고 클래스 안의 모든 코드는 같이 변경되야 한다 (!?))

여기까지 하면 추상화에 의존하기 쉬워짐

캡슐화는 (SW안에서) 변할 수 있는 어떤 개념이든 감추는 것이다
- 퍼블릭 인터페이스와 구현 분리
- `데이터/메소드 캡슐화` (private/protected)
- `객체 캡슐화`: 합성
- `서브타입 캡슐화`: 인터페이스에 의존하는 다형성

추상화 + 변하지 않는 부분으로 구성된 협력
 - 구체적인 구현에 의존할 필요없이 전체 flow파악가능
 - 이것만으로 전체적인 협력구조 설명가능

여기까지 구성했으면, 시스템이 일관적으로 구성됐고 변하지 않는 부분 (변경을 고려하지 않은 부분)이 명확하기 떄문에, __잘못 변경하기 어렵게 됨__
- 일관성 있는 협력은 개발자에게 확장포인트를 강제하기 떄문에 정해진 구조를 우회하기 어렵게 만든다

`개념적 무결성`
- 유사한 기능에 유사한 협력 패턴을 적용함으로서 유지할 수 있음
- 일관성과 동일한 뜻으로 생각해도 무방

> 협력을 일관성 있게 만든다는 것은 유사한 변경을 수용할 수 있는 협력패턴을 발견하는 것과 동일하다


### Chap 15

Martin Fowler - Analysis Patterns
- 패턴 = 여러 실무 컨텍스트에서 유용한 아이디어
- 협력하는 객체 그룹, 업무 방법 등 다 포함
- `3의 규칙`: 최소 3개 시스템에 유용한 경우만 패턴임 ㅋㅋ
- 실무지식을 축약해서 전달가능 (경험의 산물)
  - 패텬명만으로 대화를 압축가능

패턴 - 패턴 언어 = 패턴 시스템

#### 디자인 패턴
- 반복적으로 생기는 문제에 적용가능한 해결방법 (설계의 묶음)
- 목적 - 설계의 재사용
- 언어에 독립적
- __객채 간의 역할/협력이 핵심__
  - 클래스가 아니라 역할/협력이 중요 - 다양한 구현방법이 존재
ㅇㅇㄹ

`Strategy`
- 알고리즘의 변경을 캡슐화
- 다양한 알고리즘을 동적으로 교체 (합성)

`template method`
- 알고리즘의 변경을 캡슐화
- 알고리즘을 교체가능, 상속이라 런타임엔 힘듬
- 대신 코드가 더 이해하기 쉬움

`bridge`
- 추상화의 조합으로 인한 클래스의 폭발적 증가를 막기 위해, 역할과 책임을 추상화하여 두개의 집합으로 분리

`observer`
- 유연한 통지메커니즘

`Composite`
- 객체의 수를 추상화
- 컨테이너와 단일객체를 동일하게 - 클라이언트는 내가 상대하는 객체가 컨테이너인지 뭔지 알 필요 x

`decorator`
- 객체의 행동을 동적으로 추가

패턴은 출발점이다
- 패턴을 리팩토링하면서 많이 배운다고 함
- 패턴만 맹목적으로 사용하면 난해한 시스템이 나옴
  - 코드에 관련된 사람이 다 패턴을 알고 있어야 하기도 함

#### 이디엄
- 언어에 종속적인 하위레벨 패턴
- ex) C++의 counter pointer - 자바에선 무쓸모

#### 분석패턴
- 도메인 문제 해결에 초점
- 도메인 모델링 시 발견되는 구조를 표현

#### 프레임워크
- 설계 + 코드
  - = 확장 가능한 코드
- `훅 hook` 제공 (코드 템플릿)
  - 컨트롤은 프레임워크에서, 개발자는 훅만 만들 뿐
  - 설계의 재사용 가능
- 앱/도메인 간 변하는 것이 워낙 많아서, 공통 코드만 재사용하긴 어려움 - 설계도 포함

`프레임워크`
- 추상 클래스나 인터페이스를 정의하고, 인스턴스 간의 (미리 정의된) 상호작용을 통해 시스템 전체/일부를 구현해 놓은, 재사용가능한 설계
- 앱 개발자가 현 요구사항에 맞춰 커스터마이징 가능한 앱의 골격

프레임워크는 코드를 재사용함으로서 설계 아이디어를 재사용한다 (주 목적은 결국 설계의 재사용)


#### 제어 역전 원리 (Inversion of Control) = Hollywood principle
- 구현이 추상에 의존
- 절차지향 = 반대 (상위, 추상 개념이 항상 구현을 호출했음)

객체지향 설계의 재사용성은 개별 클래스가 아니라 객체들간의 공통적 협력 흐름에서 나온다
- 공통적 협력 흐름은 (오히려) 추상화를 통해 구체화될 수 있음

프레임워크에서 훅/서브타입 구현 - 해당 훅/서브타입(구체적인 구현)은 프레임워크의 추상화에 의존하게 됨
- IoC가 없는 경우 = 메인 로직을 짜고 세부구현은 라이브러리 것 사용
- IoC적용 - 훅/서브타입만 구현하고 설계는 프레임워크 것 재사용
- 협력을 제어하는 것은 프레임워크

> 객체지향의 시대에는 그저 프레임워크가 호출하는 코드를 작성해야 한다