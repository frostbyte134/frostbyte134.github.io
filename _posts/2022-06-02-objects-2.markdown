---
layout: post
title:  "Objects - 코드로 이해하는 객체지향 설계 Chap7, 8, 9"
date:   2022-06-12 08:00:05 +0800
categories: coding
use_math: true
tags: coding
---

많다 ㄷㄷ 바쁘다

> 설계는 코드 배치 방법이며 설계가 필요한 이유는 변경에 대비하기 위한 것이라는 점을 기억하라

### Chap 7
단기기억 = 5개정도까지
- 추상화 (중요한 부분만) + 분해를 통해 문제를 해결
- 객체지향은 `데이터 추상화`에 속함 (역할이 있고 책임을 수행하는 객체들로 시스템을 분해)


#### 추상화의 분류
- `프로시저 추상화`: SW가 무엇을 해야 하는지 추상화
  - `기능 분해`: = `알고리즘 분해`
- `데이터 추상화`: 소프트웨어가 무엇을 알아야 하는지 추상화
  - 데이터를 중심으로 타입을 추상화 - (?)
  - 데이터를 중심으로 프로시저를 추상화 - __객체지향__


#### 메인함수로서의 시스템
- 프로시저도 일종의 추상화임 (인터페이스만 알면 사용가능). But 한계가 있음
- 보통 탑다운 (시작: main)식으로 분해, 하위로 갈수록 구체적/상위는 추상적 함수
- 마크다운 리스트 식으로 분해

1 -> 2-> 3
1. 직원의 급여를 계산한다
2. 직원의 급여를 계산한다
  - 사용자로부터 소득세율을 입력받는다
  - 직원의 급여 계산
  - 양식에 맞게 결과 출력
3. 직원의 급여를 계산한다
  - 사용자로부터 소득세율을 입력받는다
    - "세율 입력하세요"를 화면에 출력
    - 키보드로 세율 입력받음
  - 직원의 급여 계산
    - 전역번수의 직원 기본급 정보 가져옴
    - 급여 계산
  - 양식에 맞게 결과 출력
    - "이름: {직원명}, 급여: {계산된 금액}" 형식으로 출력문자열 생성

특징
- 시스템을 메인함수로 간주
  - 각 단계는 다 함수 (sub procedures)임
  - 시스템 = 함수들의 트리
  - 단계적이고 체계적임. BUT `문제는 우리가 사는 세계는 그렇게 체계적이지도, 이상적이지도 않다는 점이다` ? 뭔가 너무...말이 추상적인데
- 기능을 중심으로 필요한 데이터 결정 - 이거 틀린건가? 메시지를 중심으로 결정해야 하나
- 유지보수 관점에서 문제가 있음
  - __처음부터 구현을 염두에 두기 때문에 (?)__ 프로시저간 temporal dependency (predecency)가 강제됨. 유연하지 못함
  - 실행순서나 조건, 반복 등의 제어구조를 미리 결정하지 않고는 분해를 진행할 수 없기 떄문에 기능분해 방식은 중앙집중 제어 스타일이 되기 쉬움 - 동격의 객체들이 협력하는 시스템이 되기 어렵다~?
- 데이터 변경 영향 컨트롤이 힘듬
  - 객체지향의 캡슐화에 대응하는 개념이 없음
  - 객체지향은 인터페이스 + 타입 (정보은닉 + 모듈화)로 벽을 세울 수 있는데, 하향식에는 인터페이스만 있음

음..아직 내생각은 결국 객체지향이 기능분해 (=프로시저 추상화)보다 좋은 건 __데이터와 연산을 모아놓았다는 것__ 밖에 없는 것 같음 (그래서 더 보기 쉽다?)


#### 모듈
- 기능을 기반으로 시스템을 분해하는 것이 아니라, 변경의 방향에 맞춰 시스템을 분해해야 함
- 변경의 방향 = 디자인패턴?

`정보 은닉` (information hiding)
- 무지성 getter/setter가 아니고, __시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 한다__ 는 것
- 모듈은 서브프로그램이라기 보단 책임의 할당이다
- __모듈과 기능분해는 상호베타적이 아니다__
  - 시스템을 모듈로 분해 (자주 변경되는 부분을 인터페이스 뒤로 숨긴 뒤)한 뒤, 기능분해를 사용해 구현 내용 정하면 됨

모듈은 다음 두 가지 비밀을 감춰야 함
- `복잡성`, `변경가능성`
- 시스템의 가장 일반적인 비밀은 데이터임
  - `데이터 캡슐화`: 데이터와 메서드를 하나의 단위로 통합하고, 퍼블릭 메서드를 통해서만 접근하게 하는 것
  - 정보은닉화의 실행 방법인 캡슐화의 한 방법

모듈의 장단점
- 장점: 변경의 경계를 제공, 비즈니스 로직과 인터페이스에 대한 관심사를 분리가능 (비즈니스 로직에서 모듈을 갖다 쓰기만 하면 됨), 전역xx제거 -> ns오염 (충돌) 방지
- 단점: 단일 객체 레벨의 추상화가 안됨 -> `추상 데이터 타입` 필요!

#### 추상 데이터 타입 (ADT)
- "직원의 급여를 계산한다" 자체를 추상화 하기보단, 직원과 급여라는 추상적인 개념을 떠올리고, 이 추상적인 개념들 (인터페이스)를 이용해 '계산'이란 동작을 수행

`타입` : 변수에 저장할 수 있는 것 + 변수에 적용될 수 있는 연산을 의미

추상 데이터 타입의 기본 의도 - built in type과 동일한 타입을 추가할 수 있게 해 줌
- 그럼 클래스는 추상 데이터 타입인가?
  - 추상 데이터 타입은 상속, 다형성을 지원하지 않음
  - 상속처럼 (직원 -(상속)-> 정규직원/알바직원)의 구조를 못 만드는 듯
    - 책의 ADT 에제에서는 함수에서 hourly변수로 타입을 넘겨받음 (허허...)
    - ADT는 오퍼레이션을 기준으로 타입을 묶음. 객체지향은 타입을 기준으로 = 데이터 추상화
  - 타입 추상화에 ADT, 객체지향이 속하고 객체지향은 또 따로 데이터 추상화 기법이다?


타입을 기반으로 절차를 추상화하지 않았다면 그것은 (클래스를 썼더라도) 객체지향 분해가 아니다
- 타입체크 조건문을 다형성으로 변경 -> 변경을 기준으로 객체지향 분해를 한 것
- 단순히 `객체지향이란 조건문을 제거하는 것` 보다는, `클라이언트가 객체의 타입을 확인해서 넘겨주는 것이 아니고, 객체가 메시지를 처리할 메서드를 선택한다`로, 주도권이 어디에 있는지 (자율적) 보면 될 듯
- 변경 시 (기존 코드를 안건드리고) 새 타입을 추가하기만 하면 됨 - `OCP`!


그럼 항상 ADT < OOP인가? - __변경의 방향에 따라 다름__
- 타입 추가가 잦다 = OOP
- 오퍼레이션 추가가 잦다 = ADT (OOP는 오퍼레이션 하나가 늘어날 때 마다 모든 서브클래스를 다 찾아가서 수정해야 함. ADT는 모든 타입을 어케 처리할 지 한곳에 모여있음)
