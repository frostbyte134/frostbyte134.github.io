---
layout: post
title:  "SWE"
date:   2019-10-04 09:00:05 +0800
categories: problem_solving
use_math: true
tags: problem_solving need_review
---

* https://solved.ac/problems/algorithms/8
* https://solved.ac/problems/algorithms/74
* https://solved.ac/problems/algorithms/68
* https://solved.ac/problems/algorithms/61
* https://solved.ac/problems/algorithms/136

천천히 합시다

`TODO`:
* 한번에 AC받는 연습하자. 꼭 제출 전에 점검 한번 합시다. 넘 귀찮긴 한데....




1. 문제리스트 easy <a href="https://baactree.tistory.com/21?category=735523" target="_blank">https://baactree.tistory.com/21?category=735523</a> - 끝
2. 문제리스트 intermediate <a href="https://baactree.tistory.com/53" target="_blank">https://baactree.tistory.com/53</a> - 거의끝
3. SWE 기본문제 <a href="https://hongjun7.tistory.com/163" target="_blank">https://hongjun7.tistory.com/163</a>
4. <a href="https://m.blog.naver.com/kks227/221382873753" target="_blank">https://m.blog.naver.com/kks227/221382873753</a>양방향탐색, trie

링크드리스트 문제 풀어야 하는데...
* https://www.acmicpc.net/problem/5397

TODO:
* trie + 아호코라식 (10256 돌연변이)

뭐지이건
* https://www.acmicpc.net/problem/3045
* https://www.acmicpc.net/problem/3649

최적값을 구하는 배열 문제 접근법
1. 왼 / 오른 / 가운데부터 접근
2. 각 trial을 쉽게 만들 수 있는가? AND __monotonic한가?__ -> 이분탐색
3. greedy 속성이 있는가? \\(i<N\\) 번째까지 만든 답 중, monotonic하게 제외할 수 있는 답이 있는가? (그래서 j>i 번째 껄 포함해서 좋은 답을 만들 수 있게) -> PQ
4. update query가 있는가? 값의 범위가 작은가? -> 구간트리
6. 좌표압축은 항상 생각하자
7. __반드시__ 문제를 먼저 손으로 풀고 할 것. 한다음에 최적화 고려합시다

* https://www.acmicpc.net/blog/view/67
* https://www.acmicpc.net/blog/view/50


### 1.18
와..망....
1. 술 안먹어도 뭐 못풀었겠지만 술 영향도 좀 컸다. 하필 어제....
2. __반드시__ 문제 먼저 손으로 풀어보고 하자. 상태 체크하는 시간이 훨씬 나중으로 주어질 때, 이전것들을 계산해야 한다는 것도 못알아챘음.
3. 구현부분은 별 문제없는 거 같긴 한데....음.........

### 반복 부분문자열
- 라빈카프 문자열 충돌은 진짜 많이난다. 1개 문자열 배열서 시작인덱스만 저장 후 비교 등으로 해결
- MOD = 10007, P = 29

### 정점들의 거리
- 이제 LCA도 비교적 기억이 잘 나는듯
- sparse table은 필요한 곳 까지만..

### 휴대폰 자판
- trie로 느리게 풀긴 풀음
- 최적화1. trie + 정렬
- 최적화2. 난 트리에 구성 후, 저장해놓은 문자열로 다시 탐색함. 그냥 트리에 자체만으로도 풀 수 있었음.

### 무한 수열
- 숫자 작을땐 배열cache. 배열cache크기~속도 였음 

### 돌연변이
- 라빈 카프
- trie + 아호코라식도 된다 함. 지금은 안봐도 될텐데...

### C형 블록맞추기
- 블록끼리 맞는 경우를 너무 소흘히 생각함. 노트에 다 써보고 하자.
- 답을 제외하는 경우를 또 해깔림.
- back(){return ary[m_size-1];}
  
### closing the farm (gold)
순서대로 닫는다 = 역순으로 연다  
문제를 잘못 이해했었음. 순서대로 닫아도 monotonic한 문제가 아닌데..이부분 실수 많이 하는듯?

### 개미굴
난 문자에 대한 trie로 풀고, start와 end를 기록 후 end에서 start까지 print함.
단어의 갯수가 적어서, 그냥 단어에 대한 trie로 해도 빨리 풀어지네?..복습요망?

### 구간 성분
문자열 2개 길이가 N이라 합시다.  
같은 부분문자열끼리만 비교할땐, 결국 O(N)개의 해시 크기만 고려하면 됨. 개꾸르  
이런경우 map대신 이진탐색이 낫네. 100ms쯤 빠름. 두배는 아니겠지 뭐  
`unsigned long long`은 자동 오버플로우 덕분에 mod가 된다? 어디서 본거같은데. 

### 신도시 전기 연결하기(?)
문제가 좀 애매하긴 했음.  
결국 각 집을 도시전기망에 연결해야 함.  
1. 집에 발전기를 놓는다
2. 어딘가 발전기로 연결한다

여기서 결국, 발전기를 K개 집에 놓을 수 있기 때문에 N-K개 집에만 전기선을 연결하면 됨. N-K개의 edge를 고르면 (2개의 집을 머징하는것) 결국 K개의 blob들이 생기므로, 각자에 발전기를 놓으면 됨.  
이런 유형을 안풀어봤나...? 엄청 해깔리네

### 1123

와...아니....다풀어놓고 ㅜㅜ
1. cache 크기를 줄여서 효율적으로 푼다는 생각을 1도 못하고 있었음
2. pseudo randon hashing은 쓰지 말자. 그리고 이것도 키를 MOD로 나눌 필요 없이 long long 키를 쓰면 됐었음
3. merge부분에서, 머지받는 쪽의 셀 갯수를 늘릴 필요가 없는데 계속 늘리고 있었다. 이거 디버깅한다고 1시간 보냄. 각 연산별로 어떤 행동을 해야 하는지 정확하게 종이에 풀고, 검증하고 ㄱㄱ.
4. 스플레이 트리 지우는 연산에서, toR 또 해깔림. 이건 뭐 조심만 하면...
5. 맞네. 문자가 10개니까 long long 1개로 비트연산으로 저장해버릴 수도 있었네. (26 < 32 = 6bit, 6 * 10 = 60bits < 64bit)

### 2048 (hard)
<a href="https://www.acmicpc.net/problem/12094" target="_blank">오졌다</a>

1. 난 각 상태공간에서 비교용 배열을 만들어서, 답(max int)과 비교하려 했음.
2. 답이 갱신됐을 때 비교용 배열을 만들고, 현재(max int)와 비교하는게 더 빠름.
3. 가지치기가 막 그렇게 concise할 필요는 없는듯. 오히려 너무 정확하게 하려다가 더 느려짐
4. easy 풀다가도 버벅거렸다. 항상 답을 depth=5에 도달할 때만 갱신하게 함. 중간에 안움직이면 종료시켰으면서....
5. map이 별 쓸모가 없네 ㄷㄷ

### Hidden anagrams
pseudo-random hasing은, 알파벳이 26개일때만 쓰자...map쓰니까 바로 맞음.
1. key를 나눠주는 modulo는 1e9+7로 하자. 사이즈와도 무관하게 할 수 있으니까 (find, update에서 시작하자마자 크기로 나눠주기)

### 사진 (D6)
1. N명이 5번 사진을 찍는데, 각 사람은 max1번만 어디든지로 움직일 수 있다.
2. 한명만 맨 끝으로 움직여도 순서가 많이 바뀌므로, 백트래킹같은건 힘듬
3. l ... r이었다 치면, r이 l왼쪽으로 갈수있는 기회는 많아야 1번.
4. 각 사람 id는 범위가 넘 크므로, 좌표압축을 씀
5. 머지소트. l, r비교시 5번동안 l이 왼쪽에 많이 있었므면 l이 작은거.
6. D7쯤 되지 않나 ㄷㄷ 이게 D6이라니. 풀긴 어케 풀었는데...

### 구간 합 (D4)
<a href="https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXGGNB6cnEDFAUo" target="_blank">링크</a>. 눈으로 보기만 합세.  
[8, 12] 의 구간 합은 (8) + (9) + (1 + 0) + (1 + 1) + (1 + 2) = 23  
123456에서, 4번째 자릿수에 나온 숫자들 합은 몇일까?
1. 일단 3 X 456 은 자명
2. 0~9가 120000번 바뀌었기에 자릿수가 그만큼 앞으로 넘어갔겠지
3. (0+1+2) * 1000도 더해주어야 함.

### 큐브 (D4)
X이하의 수 중, 세제곱수의 합으로 나타날 시 제일 많은 세제곱수의 합으로 표현되는 것은? (자기보다 작으면서 가장 큰 세제곱수를 빼 나감. <a href="https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXGPQiKdBUDFAUo&categoryId=AWXGPQiKdBUDFAUo&categoryType=CODE" target="_blank">(링크)</a>)  
1. X이하의 수 중 가장 큰 경우는? 을 상태공간으로 하는 map dp로 풀음.
2. 답이 결국 2가지 경우 중 하나로 나뉘어져서, 시간이 좀 빨리 풀린듯. 2^log2N?...



### 숫자야구게임 (review, reference problem)
문제 자체는 쉬운데, 문제에서 요구하는 것이 __빠른 해결 속도__ 가 아니라 __적은 쿼리 호출__ 임을 간과함. 진짜 1시간정도는 고민해 봐야 할듯. 

### 돌연변이 (review)
1. 라빈 카프
2. 뭘 해쉬에 넣어야 하는지 생각을 잘 합시다.
3. 의사랜덤 해쉬 + 라빈카프가 알아두기 좋은 스킬인가?...

### 합이 0인 네 정수 (reference problem)
1. 합이 0인 두 정수는 O(2*N)에 쉽게 구할 수 있다.
2. 그럼 N^2짜리 2개를 O(2*N^2)만에 구하면 N^2인데, 자꾸 O(N^2logN)만 시도하고 있었음...ㅜㅜ
3. 반으로 나누는 걸 잘 생각해 봅시다.
4. pseudo random generator를 이용한 hashing도 답 중 하나. 이게 훨 짜기 쉽고 빠름

### 미네크래프트 (reference problem)
- greedy 속성이 있는가? \\(i<N\\) 번째까지 만든 답 중, monotonic하게 제외할 수 있는 답이 있는가? (그래서 j>i 번째 껄 포함해서 좋은 답을 만들 수 있게) -> PQ
- 구간트리 코딩까지 한건 진짜 에바였다. 

### 블록 맞추기
ㄷㄷ..
1. 좌표변환 문제를 첨 풀어봐서 해깔렸다. 원래 좌표는 1번만 저장하면 되는듯.
2. map (splay tree) 구현은 되는데..실수가 좀 잦네...
3. 퀵소트떄매 몇초 차이가 난거지...?ㄷㄷ 코드베이스에 업데이트함
4. _vector는 push_back / pop_back 으로만 사용하자. 기타 잡 방법으로 조작하기 시작하면 아무리 간단한 벡터라도 에러가 터지기 시작함 (주로 동적할당에서..)
5. N개 중에서, pair를 계속 골라 나가 최적의 답을 찾아야 함.
   1. 정렬한다음, 가장 가치가 큰 것 부터 처리가능 (그리디 속성)
   2. 이 때, 내가 해깔렸던 건
      1. 현재 고려하는 i번째를 좌표변환 해서 v가 나온다고 하고, 현재것과 맞는 좌표를 계산 중(rotate 중)에 또 v가 나오면 이걸 어떻게 처리하는가? cache 배열에는 현재것도 있고, 이게 가치가 가장 큰 거니 나올텐데. 자기자신하고 매칭할 순 없으니.
      2. i번째를 고려했을 때 답이 나왔으면, 나중에 i번째를 고려하지 못하게 마킹해야 하는가? i번째와 매칭되는 (가치가 낮은) j번째를 마킹해야 하는 것은 자명함
      3. 답은 `칼라볼` 문제 식의...__i번째를 고려할 때면 cache에서 i번째를 걍 빼면 된다.__ 매칭은 양방향이므로 i보다 가치가 낮은 j번째에서 i를 고려할 일이 없기 때문.

### Piet
<a href="https://www.acmicpc.net/problem/15949" target="_blank">https://www.acmicpc.net/problem/15949</a>
* 많이 본 완탐 패턴. 보드판 각 점에서, 해당 점이 속하는 blob의 4방향 끝점까지를 많이 구해야 함.
* 난 BFS 1번으로 각 점이 어느 blob에 속하는지 기록하고, 다시 BFS돌려서 해당 blob의 leftmost / rightmost / topmost / undermost 좌표를 구해서 저장한 다음, 다시 해당 점을 고려해야 할 때 N*N대신 이 정보로 N의 탐색을 했었음.
* 근데 생각해보면, 점과 8개의 방향이 정해지면 결과는 deterministic하게 나오므로, 이걸 미리 다 찾아놓고 저장(N*N*8*2) 하는 게 훨씬 빨랐을듯 (N -> 1)

### 큐빙
<a href="https://www.acmicpc.net/problem/5373" target="_blank">https://www.acmicpc.net/problem/5373</a>
1. 이런 류의, 같은 동작을 여러 곳에서 하는 완전탐색은, 특정 상태를 가정한 동작을 하나만 구현하고 다른 상태를 그 특정 상태로 천이시킬 수 있는지 봐야 함
2. 이 문제에선 위에서의 면 전환만 구현하고,
   1. 큐브를 굴려서 대상 면을 위로 올린 후
   2. 면 전환
   3. 다시 큐브를 굴려서 (4 - 1번에서 굴린 횟수. 4번 굴리면 원상복귀하므로) 원복
   의 과정을 수행함
3. 이 때, 결국 면 전환은 위에서만 돌릴 것이므로, 큐브를 (오른쪽 또는 앞쪽으로) 굴려서 윗 면을 옆/오른쪽으로 보낼 때 원래 좌표계의 기준으로 돌아올 수 있으면 됨. 근데 
   1. 큐브를 굴릴 때 결국 옆면도 굴려야 하므로, 이 부분에서 좀 시간이 걸렸다. 윗면 좌표계를 (오른 / 왼) 쪽으로 굴렸을때 옆면에서는 어떻게 되는지, 그리고 여기서 (윗면이 오른 / 왼 쪽으로 가 버린 상태에서) 굴렸을 때 어떻게 변하는지를 구현했어야 했음.  
   2. 오른쪽으로 굴렸을 때, 그리고 앞으로 굴렸을 때 밑면에서 좌표 저장 방식이 충돌이 났음 (서로 다름). 이 부분도 해결해 줘야 했다. 오른쪽에서 굴린 면이 아래로 갔을 때, 아래에서 왼쪽으로 올 때 이 두 경우를 고려함.
4. 더 깔끔한 방법이 없을까..큐브를 육면체에 놓고 해 볼까?

### BOARDCOVER
내생각에, 알고스팟 보드커버류 완탐이 나올수도 있을 듯. 종만북 TSP도 다시 봐보는게 어때? NP최적화의 기본이자너

### 탈옥1 (review. 필수)
<details>
<summary>후기</summary>
1. 문은 결국, 레벨별로 생각할 수 있음. 그리고 레벨만 구할라면 (내가 했던 방법인) 2중 큐보다는 vis를 dist로 대체하는 것이 간편해 보인다.<br/>
2. 난 (두명에서 출발하는) 레벨을 전부 샌 후, 만나기 전까지는 X2, 만난 후에는 X1로 하려고 했었음. 여기서 생긴 문제는, 탈출했을 때 어느 문을 사용했는 지 모르므로 문이 겹칠 수도 아닐 수도 있다는 것.<br/>
3-1. 바깥에 테두리로 두르고 탈출용 1인을 더 추가하기 (핵심)<br/>
3-2. 3명이서 만난 레벨 (벽이면 1명만 문을 열면 되므로 -2. 답이 벽이 아닌 곳에 있는 경우도 있다. 그냥 빠져나갈 수 있는 경우.)중 최소가 답.<br/>
</details>

### 가장 큰 정사각형 (review)
<details>
<summary>후기</summary>
난 부분합으로 풀었지만..더 쉽게 푸는법은, 일단 0열 0행은 보드와 같이 초기화해놓고, s[i][j] = min(s[i-1][j], s[i][j-1], s[i-1][j-1]) 로 해서 0이 아니면 변길이 s[i][j]크기의 정사각형이 있는 것.
 </details>


###  배달 (review)
<details>
<summary>후기</summary>
 - 어디를 들렸다 오는건, 달이차오른다류 비트마스크 dp. 아니면 2개뿐이었으니까, A->B, B->A만 비교해봐도 됬을 듯. <br/>
 - 종료조건은 현재노드에서 확인해도, 다음 노드를 갈 땐 상태를 완벽하게 갱신해 주고 가자<br/>
 - 배열은 무조건 +1. 이문제서도 원래노드에서 상태갱신하다가 2밖에 안되는줄알았는데, 이전노드에서 갱신해주고 오면서 3까지 되서 틀림
</details>

### 합성함수와 쿼리
cout이 이렇게 안좋나? 문제는 sparse table임. 2^i만큼 빼주면서 ㄱㄱ

### 버블 소트
<a href="https://www.acmicpc.net/problem/1517" target="_blank">https://www.acmicpc.net/problem/1517</a>

값들을 좌표압축 (소트 필요) 한 후 구간트리로 풀음


### 치즈 (review...?)
<details>
<summary>후기</summary>
내부 공기의 처리를 생각 못함. 사각형 속이 빈 예제만 만들어봤어도 될텐데 말이야..
 </details>

### 구슬 탈출 2 (review)
구현 설계

### 2048 (review)
- 각 보드판을 처리하기 전에, (0만으로 이루어진 경우가 아니면) 위로는 더이상 0이 없게 땡겨야 하는 조건을 명확하게 정의하지 않음0
- 이거 SWE사이트에 비슷한문제 있던데 그걸 푸는 걸로 리뷰 대체하자


### 사다리 조작 (Reference problem)
<a href="https://www.acmicpc.net/source/15014256" target="_blank">주석 있는 소스 링크</a> 완전탐색 복습 시 보기 좋은듯. 
<details>
<summary>후기</summary>
1. 완전탐색중 매번마다 보드판만큼 답의 validity를 검사해야 했음. 이러면 validity 검색 중 멈출 수 있으면 바로 멈추고 몸체부분으로 넘어가는게 낫지  <br/>
2. 상태공간 끝까지 검사 안해도 되면 중간에 멈추기  <br/>
3. 재귀함수 호출 줄이기: 일부 상태공간을 건너뛰어도 되면, 한 함수 내애서 건너뛰어 버리기  
</details>


### 아기 상어
* <a href="https://www.acmicpc.net/problem/16236" target="_blank">link</a>
* `보드판에서 같은 거리일 시 윗쪽부터, 그것도 같으면 왼쪽부터` 를, dx = [-1, 0, 0, 1], dy = [0, -1, 1, 0]으로 해결할 수 있다고 생각해서 30분을 날려먹었다. 2번째 레벨부터 깨짐. 그냥 소팅으로 해결
* 이거도 결국 `Piet`문제처럼 각 point마다 가야하는 곳이 deteministic하게 정해지는 거면, 다 찾아놓고 해도 되지 않나?


### QR
<a href="https://www.acmicpc.net/problem/2680" target="_blank">https://www.acmicpc.net/problem/2680</a>
* 문제가 길어지니까 사소한 실수가 많아짐. 연산의 결과가 0이면 스킵하라고 했는데, 원래 정의한 상태에선 0도 처리해야 했었다. 그래서 두어번 틀림. 이거 찾는것도 힘든듯. 근데 말이 너무 기니까 좀 풀기가 귀찮다...


### 연구소 3
<a href="https://www.acmicpc.net/problem/17142" target="_blank">link</a>
1. 각 바이러스 별로, bfs로 도달 cache를 만드는것까진 명확
2. M(1~10) 개의 바이러스를 골랐을 때, 만들 수 있는 최소 시간은?
	1. 여기서 난 삼천포로 빠져서, 동적계획법을 생각했다. 
	2. 2개의 페어 10C2개를 저장하고, 3개의 페어 10C3개는 2개의 페어 캐쉬에서 만들고...
	3. O(45 (10C2) + 120 (10C3) + ... + 252 (10C5)) 일 것이므로 가짓수는 적을 텐데, 이걸 어떻게 저장하느냐 생각 중이었음. map으로 어렵지 않게 될 것 같긴 한데...splay tree로 map 구현해서 꼭 해 보자.
3. 결국, 순서를 강제하고 DFS로 풀면 어느 정도의 cache효과 (페어, 트리플렛 등을 중복 계산하지 않는)를 얻을 수 있음. 근데 내 생각엔 이게 좀 더 느린 것 같다
   1. 왜냐하면, 예를 들어 [1, 2, 3, 4, 5]서 앞부터 순서를 강제한다고 하면, [1, 2, 4, 5]와 [1, 3, 4, 5] 계산에서 [4, 5]페어는 두번 중복 계산되기 때문. 결국 문제를 어렵게 낸다고 하면, map을 이용한 캐싱을 해야 할 듯
4. splay tree를 이용한 caching을 해 봤지만 그게 그거였다. 탐색공간이 넘 작아서인듯


### 퍼즐
퍼뮤테이션이라 의외로 가지수가 작았다. 보드판의 bijection을 만들 수 있는 경우를 생각해야 함.

### 쉬운것들
- 테트리스 게임 - 더러운 테트노미로 류


### 안전영역
 - 레벨별로 bfs돌리면서 각 레벨에 고유영역들을 세 주네..유니온 앤 파인드가 더 빠르긴 하겠지만..?

### MAZE
 - 째로류 게임은 한번 왼쪽 했으면 다시 왼쪽 돌릴 필요는 없음.

### 미로만들기
 - bfs로 인한 propagation. 이번 턴에 갈 수 있는 곳 = Q, 다음 턴에 갈 수 있는 곳 = nQ, 와일문 처음에 Q = nQ; (42분)) 와 비교


### 말이 되고픈 원숭이
1. 다익스트라가 더 빠른가?
2. W, H가 일반적인 문제와는 반대로 되어 있다. 문제를 잘 읽읍시다



### 백조의 호수
 - 보드판에서 녹이기의 정석. 여러군대서 bfs를 시작해야 되서 귀찮기도 함. bfs는 꼭 함수화 시켜놓자.
 - 역시 (느리지만) 가장 확실하게 푸는 건,
 1. bfs돌리고 부딧친 벽은 벡터에 저장
 2. 벡터에 저장된 벽 녹이고 큐에 저장
 3. 다시 bfs
 인듯. 그리고 이경우는 백조2마리 (1, 2)가 녹이는 vis(3)을 오버라이딩 할 수 있게 해주는 것이 중요 (반대는 안되게).
 - 다익스트라가 안되는 이유 = 양방향에서 녹으므로 (dist+1)/2를 할라고 했는데, 가운데 뭔가 하나 끼어있는 경우는 /4겠지?
 - 마지막으로 제일 중요한 것 - 벽에서 만난다고 끝이 아님. 벽 아닌 곳에서 만날수도 있다. ret = min을 해줘야...


### 일요일 아침의 데이트
 - 벽넘는 시뮬레이션은 대부분 거리(+다익스트라?)로 풀 수 있는듯. 큰 쓰레기는 1만, 작은 쓰레기는 1로 하면 겹칠일이 없다.
 - 또는 원숭이 문제처럼, 일반->벽옆->벽 을 변하는게 없을때까지...


### 다시구현
JLIS - DP식유도 실패(이중 포문 사용). 식 유도만 다시해보자.
TRAVERSAL - 왜캐 구현 못해졌지..
뱀(어려운거) - 두 선분의 교차조건을 확실하게 정의하지 못해 코드가 더러워졌다. 구사과님꺼 input.txt에 복사해놓음.
BOARDCOVER(1, 2?)
WORDCHAIN - 오일러. 다까먹음. ㅅㅂ
SORTING GAME - map을 이용한 BFS.
 - map 이용시에 vis판별은 count함수로 해야 함. []로 했더니 틀리네..
 - 미리 만들어놓고 함.

째로탈출1 - 내 bfs는 검사를 노드에서 꺼냈을 때 하므로, 10번째 레벨까지 검사하고 싶으면 11번째를 돌려야 함.
퇴사 - DP를 풀땐 귀찮더라도 점화식 확실하게 쓰고 풀자. 그게 시간을 더 아낄 수 있는듯


벽 부수기 2
 - 플로이드형 DP. 거리의 정의를 잘 정의해야 됨. 그냥 배열 1개에 때려박았다가 틀림.

로봇 시뮬레이션
 - 보드판의 좌표축을 꼬아 놓은 문제...bijection이 한번 꼬이니 쉽게 정의가 안되는군.
Coloured Bead Works
 - 띠용...
 - 1/N을 계속 곱해가는 것 보단, /N만 계속 하는게 훨 나은가 보다..그렇게 생각할 수 밖에 없네. 맞긴 하겠지만 답에 영향을 줄 정도인가?


삼성익스퍼트
보호 필름 - ㅅㅂ
벌꿀 채취 - 케이스가 작아서 쉬웠다. 보니까 메모리를 전혀 안쓰는 방법도 있는 모양인데?
등산로 조성
 - 1. 중요!!!! 산을 깎을 수 있다면 ret = max(ret, 2)를 해 줘야 하는데 안하고 바로 깎은 곳에서 다음 산으로만 해버림. 이런 실수 찾기 엄청 힘든데...
 - 2. 이전 좌표와 같지 않다는 걸 px != x && py != y로 해버림. 그냥 컨티뉴로 하자. if(px == x && py == y)continue로...  	
수영장 - 노코멘트
차량 정비소 - 말이 많다. 시간남으면 다시 함 해볼까..
점심시간
- 케이스가 작아서 완탐함
- 포문에 for쪽에 거르는 조건을 넣어서 포문이 걍 끊겼다 ㅡㅡ.....
- 사람배열을 조건에 맞는걸로 새로 만들어 짧게 하려다가, p의 시멘틱이 달라지는 경우도 생김.
미생물 격리
- 또 한번을 더돌음
범준이의 제주도 여행계획
- 그냥 더러운 문제였다. 돌아가지 않는다는 게...참......
디저트 카페
- 4방향을 돌아야 되니까, 각 방향에서 원래 방향으로 계속 가는것과 다음 방향으로 가는걸 고려해 줘야 됨.
생각만

열쇠 - 첨에는 뭔 bfs와 dfs를 같이하는거라고 생각했다. 대부분 이런 경우 vis를 리셋하고 bfs를 첨부터 다시 시작하면 좋을듯.
 - 확실히 이런 문제엔 DFS는 안어울리겠지..
 - 두번째 구현은 확실히 보기 좀 괜찮아짐 ㅎㅎ
달이차오른다가자 - 뭘 이렇게 틀렸지..키판에서 새 키가 아니어도 보드에 놔 줘야 했는데, 이 부분을 체크 못함. 그냥 템프 변수 만들어서 할껄...쨋든 비트마스크 BFS.
 - 비트마스크 배열 만들때, 6번째까지 할꺼면 (1<<6)+1 이아니라 (1<<7)+1이다. 111111>(1>6)이기 때문
신기한 소수 - 에라스토테네스의 채를 안써도 되넹 신기해라
DSLR - vis배열은 parents로 대체가능. 각 숫자마자 오게 된 char를 기록하면 좀 더 빠른가?..그게 그거일듯
불!
 - 불 난곳에 다시 갈 필욘 없는데..이거 빼먹었다가 메모리 초과(ㅡㅡ;;;;)남
동전 문제 - 멍청했다.
 - 1, 25, 100인 동전 dp면, 오른쪽 2자리 (작은 숫자)부터 해야지...왼쪽부터 하면 3자리에 대해 처리하는 경우가 생기잖니
Puyo Puyo - 2048류의 빈칸 처리가 핵심. 2048보단 훨쉬운듯..
게임 - DFS + DP
케빈 베이컨 - BFS를 N번 돌리는 것 보단 역시 플로이드가 낫겠지..(N=500정도까진)
펠린드롬 만들기 - "사전순"으로 제일 앞서는..모든 케릭터의 반을 (사전순으로) (odd출현 케릭터도) 앞에 붙이고, odd케릭터 있으면 붙이고, 다시 역순 붙이면 됨.
말이되고픈몽키 - K번 쓸 수 있다면 류 dp. 탑코더때 푼 거 기억나지?
FORTRESS - 미스1. 거리계산 실수. 미스2. 트리에서 두 노드간의 최단거리 중 가장 긴 거리는 루트를 거치지 않을 수도 있다. 이 생각을 못했네..
MATCHORDER - 식 유도만. 약한 애를 약한 애로 잡아야 한다. 강한 애부터 약한 애로 잡으면, 약한 애한테 이길 수도 있는 우리편이 희생될수있기떄문 (상대할 적을 한명 배정해야하기 때문에)
CLOCKSYNC - 재귀 완전탐색시는 꼭 원래대로 돌려놓자. 맨 윗 단에서는 문제없겠지만 밑에 호출되는 애들에서 문제있음.
QUADTREE - string(1, word[ind])
FENCE - mid = (l+r)/2, [l,mid], [mid+1,r], (0,N-1)
시험감독 - 음수%C, 오버플로우
구슬 탈출 2 - must. (ro90은 보드판을 직접 저장할 경우에만 가능. 또는 N/M이 나뉘지 않은 경우). 보드판에서 시뮬레이션을 할 필요가 없다. r, b만 움직이면 됨.
   	-1. r, b가 겹치는 경우 - 골인판에 들어가면 ㅂㅂ. 아니면 온 거리를 계산해서 먼 쪽을 한칸 뺀다.
	-2. 어느 방향에서 도착하든 상관없는데, 난 도착한 방향까지도 상태공간에 포함시켰다. ㅜㅜ

환승 - 메모리 큰 BFS문제 (+하이퍼엣지?). 난 하이퍼노드끼리의 BFS로 풀었지만, adj[노드][하이퍼노드]와 ary[하이퍼노드][K]를 저장해 놓고, 노드의 BFS로 (adj 판별 - 노드의 하이퍼노드의 ary참조)풀면 더 빠른 듯하다.
GALLERY - 트리의 지배집합. 3가지 상태가 있다. 첨에는 2가지상태로만 해서 계속 틀림.
    	- 알고리즘 구현 상 루트노드에 대한 처리를 따로 해 주어야 한다. 부모 노드에서야 자식 노드의 지배여부가 완전히 결정되는데, 알다시피 루트에는 부모 노드가 없기 때문.
불 - 큐2개로, 1개는 탈출 루트용, 1개는 불 퍼지는 용. 불 쪽의 vis는 유지할 필요가 없었군. 불이면 안가면 되니. (30분)

종이조각 - 확실하게 알 수 있는 것부터 dp를 만들어가자. 이 문제는 범위가 4여서 좀 특이했음.
SNAKE(쉬움) - int dxt = dX[bodir[sXT][sYT]], dyt = dY[bodir[sXT][sYT]]; sXT += dxt, sYT += dyt; 이케 안해줌 꼬임
  	- 시간 업데이트 후 현재 보드판의 방향을 기록해야 했는데 안해서 런타임3번제출함 ㅄ
   - 감소 : (dir + 3)%4;
통나무 옮기기 - 멍청하게 옮길 때 가운데는 체크안하고 양옆만 체크함.
로봇 - 아니 지금 1또는2또는3을 안읽어서 틀리신 거에요?....

연구소 - 예제는 한번 풀어보고 하자...

테트노미로 - 대칭을 못봐서 함 틀림. 어쨋건, 이런 도형 갖다붙이는 문제는 dfs로 접근해 보자. DFS로 풀어봅시다.
집 구하기
 - 동시에 시작하는 다익스트라
1로 만들기
 -1은 함정. /2나 /3보다 나은 것이 전혀 없다.
