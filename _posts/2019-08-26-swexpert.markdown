---
layout: post
title:  "SWE"
date:   2019-8-25 09:00:05 +0800
categories: problem_solving
use_math: true
tags: problem_solving need_review
---

천천히 합시다

`TODO`:
* 이전 복습 리스트 정리 및 풀어보기
* 연구소3 좌표압축으로 풀어보기 (빨리!)
* 한번에 AC받는 연습 하자. 좀 늦게 내더라도...귀찮더라도.,......

1. 문제리스트 easy <a href="https://baactree.tistory.com/21?category=735523" target="_blank">https://baactree.tistory.com/21?category=735523</a>
2. 문제리스트 hard <a href="https://baactree.tistory.com/53" target="_blank">https://baactree.tistory.com/53</a>
	* vector를 내가 직접 구현해야  
	
3. 문제리스트 hard <a href="https://hongjun7.tistory.com/163" target="_blank">https://hongjun7.tistory.com/163</a>

### 아기 상어
* <a href="https://www.acmicpc.net/problem/16236" target="_blank">link</a>
* `보드판에서 같은 거리일 시 윗쪽부터, 그것도 같으면 왼쪽부터` 를, dx = [-1, 0, 0, 1], dy = [0, -1, 1, 0]으로 해결할 수 있다고 생각해서 30분을 날려먹었다. 2번째 레벨부터 깨짐. 그냥 소팅으로 해결

### 연구소 3
<a href="https://www.acmicpc.net/problem/17142" target="_blank">link</a>
1. 각 바이러스 별로, bfs로 도달 cache를 만드는것까진 명확
2. M(1~10) 개의 바이러스를 골랐을 때, 만들 수 있는 최소 시간은?
	1. 여기서 난 삼천포로 빠져서, 동적계획법을 생각했다. 
	2. 2개의 페어 10C2개를 저장하고, 3개의 페어 10C3개는 2개의 페어 캐쉬에서 만들고...
	3. O(45 (10C2) + 120 (10C3) + ... + 252 (10C5)) 일 것이므로 가짓수는 적을 텐데, 이걸 어떻게 저장하느냐 생각 중이었음. 좌표 압축으로 어렵지 않게 될 것 같긴 한데...__(나중에 꼭 해 보자)__ 제출 수 보아하니 그렇게 어렵게 푸는 것 같진 않은데..
3. 결국, 순서를 강제하고 DFS로 풀면 어느 정도의 cache효과 (페어, 트리플렛 등을 중복 계산하지 않는)를 얻을 수 있음. 근데 내 생각엔 이게 좀 더 느린 것 같다
4. 왜냐하면, 예를 들어 [1, 2, 3, 4, 5]서 앞부터 순서를 강제한다고 하면, [1, 2, 4, 5]와 [1, 3, 4, 5] 계산에서 [4, 5]페어는 두번 중복 계산되기 때문. 결국 문제를 어렵게 낸다고 하면, 위의 좌표압축 + caching 방법을 써야 할 듯


복습 리스트
- 가장 큰 정사각형 : corner case
- 구슬 탈출 2 : 구현 설계
- 퍼즐 - 퍼뮤테이션이라 의외로 가지수가 작았다. 보드판의 bijection을 만들 수 있는 경우를 생각해야 함.

### 쉬운것들
- 테트리스 게임 - 더러운 테트노미로 류


### 안전영역
 - 레벨별로 bfs돌리면서 각 레벨에 고유영역들을 세 주네..유니온 앤 파인드가 더 빠르긴 하겠지만..?

### MAZE
 - 째로류 게임은 한번 왼쪽 했으면 다시 왼쪽 돌릴 필요는 없음.

### 미로만들기
 - bfs로 인한 propagation. 이번 턴에 갈 수 있는 곳 = Q, 다음 턴에 갈 수 있는 곳 = nQ, 와일문 처음에 Q = nQ; (42분)) 와 비교

### 백조의 호수
 - 보드판에서 녹이기의 정석. 여러군대서 bfs를 시작해야 되서 귀찮기도 함. bfs는 꼭 함수화 시켜놓자.
 - 역시 (느리지만) 가장 확실하게 푸는 건,
 1. bfs돌리고 부딧친 벽은 벡터에 저장
 2. 벡터에 저장된 벽 녹이고 큐에 저장
 3. 다시 bfs
 인듯. 그리고 이경우는 백조2마리 (1, 2)가 녹이는 vis(3)을 오버라이딩 할 수 있게 해주는 것이 중요 (반대는 안되게).
 - 다익스트라가 안되는 이유 = 양방향에서 녹으므로 (dist+1)/2를 할라고 했는데, 가운데 뭔가 하나 끼어있는 경우는 /4겠지?
 - 마지막으로 제일 중요한 것 - 벽에서 만난다고 끝이 아님. 벽 아닌 곳에서 만날수도 있다. ret = min을 해줘야...

###  배달
 - 봐서 다행..
 - 어디를 들렸다 오는건, 달이차오른다류 비트마스크 dp. 아니면 2개뿐이었으니까, A->B, B->A만 비교해봐도 됬을 듯.
 - 종료조건은 현재노드에서 확인해도, 다음 노드를 갈 땐 상태를 완벽하게 갱신해 주고 가자
 - 배열은 무조건 +1. 이문제서도 원래노드에서 상태갱신하다가 2밖에 안되는줄알았는데, 이전노드에서 갱신해주고 오면서 3까지 되서 틀림

### 일요일 아침의 데이트
 - 벽넘는 시뮬레이션은 대부분 거리(+다익스트라?)로 풀 수 있는듯. 큰 쓰레기는 1만, 작은 쓰레기는 1로 하면 겹칠일이 없다.

### BOARDCOVER

### 탈옥1
1. 문은 결국, 레벨별로 생각할 수 있음. 그리고 레벨만 구할라면 (내가 했던 방법인) 2중 큐보다는 vis를 dist로 대체하는 것이 간편해 보인다.
2. 난 (두명에서 출발하는) 레벨을 전부 샌 후, 만나기 전까지는 X2, 만난 후에는 X1로 하려고 했었음. 여기서 생긴 문제는, 탈출했을 때 어느 문을 사용했는 지 모르므로 문이 겹칠 수도 아닐 수도 있다는 것.
3-1. 바깥에 테두리로 두르고 탈출용 1인을 더 추가하기 (핵심)
3-2. 3명이서 만난 레벨 (벽이면 1명만 문을 열면 되므로 -2. 답이 벽이 아닌 곳에 있는 경우도 있다. 그냥 빠져나갈 수 있는 경우.)중 최소가 답.

다시구현
JLIS - DP식유도 실패(이중 포문 사용). 식 유도만 다시해보자.
TRAVERSAL - 왜캐 구현 못해졌지..
뱀(어려운거) - 두 선분의 교차조건을 확실하게 정의하지 못해 코드가 더러워졌다. 구사과님꺼 input.txt에 복사해놓음.
BOARDCOVER(1, 2?)
WORDCHAIN - 오일러. 다까먹음. ㅅㅂ
SORTING GAME - map을 이용한 BFS.
 - map 이용시에 vis판별은 count함수로 해야 함. []로 했더니 틀리네..
 - 미리 만들어놓고 함.
  
벽 부수기 2
 - 플로이드형 DP. 거리의 정의를 잘 정의해야 됨. 그냥 배열 1개에 때려박았다가 틀림.

로봇 시뮬레이션
 - 보드판의 좌표축을 꼬아 놓은 문제...bijection이 한번 꼬이니 쉽게 정의가 안되는군.
Coloured Bead Works
 - 띠용...
 - 1/N을 계속 곱해가는 것 보단, /N만 계속 하는게 훨 나은가 보다..그렇게 생각할 수 밖에 없네. 맞긴 하겠지만 답에 영향을 줄 정도인가?


삼성익스퍼트
보호 필름 - ㅅㅂ
벌꿀 채취 - 케이스가 작아서 쉬웠다. 보니까 메모리를 전혀 안쓰는 방법도 있는 모양인데?
등산로 조성
 - 1. 중요!!!! 산을 깎을 수 있다면 ret = max(ret, 2)를 해 줘야 하는데 안하고 바로 깎은 곳에서 다음 산으로만 해버림. 이런 실수 찾기 엄청 힘든데...
 - 2. 이전 좌표와 같지 않다는 걸 px != x && py != y로 해버림. 그냥 컨티뉴로 하자. if(px == x && py == y)continue로...  	
수영장 - 노코멘트
차량 정비소 - 말이 많다. 시간남으면 다시 함 해볼까..
점심시간
- 케이스가 작아서 완탐함
- 포문에 for쪽에 거르는 조건을 넣어서 포문이 걍 끊겼다 ㅡㅡ.....
- 사람배열을 조건에 맞는걸로 새로 만들어 짧게 하려다가, p의 시멘틱이 달라지는 경우도 생김.
미생물 격리
- 또 한번을 더돌음
범준이의 제주도 여행계획
- 그냥 더러운 문제였다. 돌아가지 않는다는 게...참......
디저트 카페
- 4방향을 돌아야 되니까, 각 방향에서 원래 방향으로 계속 가는것과 다음 방향으로 가는걸 고려해 줘야 됨.
생각만

열쇠 - 첨에는 뭔 bfs와 dfs를 같이하는거라고 생각했다. 대부분 이런 경우 vis를 리셋하고 bfs를 첨부터 다시 시작하면 좋을듯.
 - 확실히 이런 문제엔 DFS는 안어울리겠지..
 - 두번째 구현은 확실히 보기 좀 괜찮아짐 ㅎㅎ
달이차오른다가자 - 뭘 이렇게 틀렸지..키판에서 새 키가 아니어도 보드에 놔 줘야 했는데, 이 부분을 체크 못함. 그냥 템프 변수 만들어서 할껄...쨋든 비트마스크 BFS.
 - 비트마스크 배열 만들때, 6번째까지 할꺼면 (1<<6)+1 이아니라 (1<<7)+1이다. 111111>(1>6)이기 때문
신기한 소수 - 에라스토테네스의 채를 안써도 되넹 신기해라
DSLR - vis배열은 parents로 대체가능. 각 숫자마자 오게 된 char를 기록하면 좀 더 빠른가?..그게 그거일듯
불!
 - 불 난곳에 다시 갈 필욘 없는데..이거 빼먹었다가 메모리 초과(ㅡㅡ;;;;)남
동전 문제 - 멍청했다.
 - 1, 25, 100인 동전 dp면, 오른쪽 2자리 (작은 숫자)부터 해야지...왼쪽부터 하면 3자리에 대해 처리하는 경우가 생기잖니
Puyo Puyo - 2048류의 빈칸 처리가 핵심. 2048보단 훨쉬운듯..
게임 - DFS + DP
케빈 베이컨 - BFS를 N번 돌리는 것 보단 역시 플로이드가 낫겠지..(N=500정도까진)
펠린드롬 만들기 - "사전순"으로 제일 앞서는..모든 케릭터의 반을 (사전순으로) (odd출현 케릭터도) 앞에 붙이고, odd케릭터 있으면 붙이고, 다시 역순 붙이면 됨.
말이되고픈몽키 - K번 쓸 수 있다면 류 dp. 탑코더때 푼 거 기억나지?
FORTRESS - 미스1. 거리계산 실수. 미스2. 트리에서 두 노드간의 최단거리 중 가장 긴 거리는 루트를 거치지 않을 수도 있다. 이 생각을 못했네..
MATCHORDER - 식 유도만. 약한 애를 약한 애로 잡아야 한다. 강한 애부터 약한 애로 잡으면, 약한 애한테 이길 수도 있는 우리편이 희생될수있기떄문 (상대할 적을 한명 배정해야하기 때문에)
CLOCKSYNC - 재귀 완전탐색시는 꼭 원래대로 돌려놓자. 맨 윗 단에서는 문제없겠지만 밑에 호출되는 애들에서 문제있음.
QUADTREE - string(1, word[ind])
FENCE - mid = (l+r)/2, [l,mid], [mid+1,r], (0,N-1)
시험감독 - 음수%C, 오버플로우
구슬 탈출 2 - must. (ro90은 보드판을 직접 저장할 경우에만 가능. 또는 N/M이 나뉘지 않은 경우). 보드판에서 시뮬레이션을 할 필요가 없다. r, b만 움직이면 됨.
   	-1. r, b가 겹치는 경우 - 골인판에 들어가면 ㅂㅂ. 아니면 온 거리를 계산해서 먼 쪽을 한칸 뺀다.
	-2. 어느 방향에서 도착하든 상관없는데, 난 도착한 방향까지도 상태공간에 포함시켰다. ㅜㅜ
2048  - 각 보드판을 처리하기 전에, (0만으로 이루어진 경우가 아니면) 위로는 더이상 0이 없게 땡겨야 하는 조건을 명확하게 정의하지 않음0
환승 - 메모리 큰 BFS문제 (+하이퍼엣지?). 난 하이퍼노드끼리의 BFS로 풀었지만, adj[노드][하이퍼노드]와 ary[하이퍼노드][K]를 저장해 놓고, 노드의 BFS로 (adj 판별 - 노드의 하이퍼노드의 ary참조)풀면 더 빠른 듯하다.
GALLERY - 트리의 지배집합. 3가지 상태가 있다. 첨에는 2가지상태로만 해서 계속 틀림.
    	- 알고리즘 구현 상 루트노드에 대한 처리를 따로 해 주어야 한다. 부모 노드에서야 자식 노드의 지배여부가 완전히 결정되는데, 알다시피 루트에는 부모 노드가 없기 때문.
불 - 큐2개로, 1개는 탈출 루트용, 1개는 불 퍼지는 용. 불 쪽의 vis는 유지할 필요가 없었군. 불이면 안가면 되니. (30분)

종이조각 - 확실하게 알 수 있는 것부터 dp를 만들어가자. 이 문제는 범위가 4여서 좀 특이했음.
SNAKE(쉬움) - int dxt = dX[bodir[sXT][sYT]], dyt = dY[bodir[sXT][sYT]]; sXT += dxt, sYT += dyt; 이케 안해줌 꼬임
  	- 시간 업데이트 후 현재 보드판의 방향을 기록해야 했는데 안해서 런타임3번제출함 ㅄ
   - 감소 : (dir + 3)%4;
통나무 옮기기 - 멍청하게 옮길 때 가운데는 체크안하고 양옆만 체크함.
로봇 - 아니 지금 1또는2또는3을 안읽어서 틀리신 거에요?....
째로탈출1 - 내 bfs는 검사를 노드에서 꺼냈을 때 하므로, 10번째 레벨까지 검사하고 싶으면 11번째를 돌려야 함.
퇴사 - DP를 풀땐 귀찮더라도 점화식 확실하게 쓰고 풀자. 그게 시간을 더 아낄 수 있는듯
가장 큰 정사각형
 - 난 부분합으로 풀었지만..더 쉽게 푸는법은, 일단 0열 0행은 보드와 같이 초기화해놓고, s[i][j] = min(s[i-1][j], s[i][j-1], s[i-1][j-1]) 로 해서 0이 아니면 변길이 s[i][j]크기의 정사각형이 있는 것.
 치즈 - 내부 공기의 처리를 생각 못함. 사각형 속이 빈 예제만 만들어봤어도 될텐데 말이야..
연구소 - 예제는 한번 풀어보고 하자...

테트노미로 - 대칭을 못봐서 함 틀림. 어쨋건, 이런 도형 갖다붙이는 문제는 dfs로 접근해 보자. DFS로 풀어봅시다.
집 구하기
 - 동시에 시작하는 다익스트라
1로 만들기
 -1은 함정. /2나 /3보다 나은 것이 전혀 없다.
