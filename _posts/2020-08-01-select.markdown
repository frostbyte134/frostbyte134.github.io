---
layout: post
title:  "select / epoll"
date:   2020-07-24 09:00:05 +0800
categories: problem_solving
use_math: true
tags: problem_solving need_review coding
---

<a href="http://www.kegel.com/c10k.html" target="_blank">The C10K Problem</a>

(e)poll vs select
- <a href="https://daniel.haxx.se/docs/poll-vs-select.html" target="_blank">https://daniel.haxx.se/docs/poll-vs-select.html</a>
    - poll이랑 select는 비슷하고, epoll은 event driven?
- <a href="https://ozt88.tistory.com/21" target="_blank">https://ozt88.tistory.com/21</a> 
    > epoll은 select의 단점을 많이 개선한 형태의 통지방식이다. FD_SET을 운영체제가 직접 관리하는 것으로 많은 부분이 개선되었다. 하지만 그 본질적인 동작 구조는 select와 크게 다르지 않다. 프로세스가 커널에게 지속적으로 I/O 상황을 체크하여 동기화 하는 개념은 여전히 유효하다. 따라서 epoll의 통지모델 역시 동기형 통지모델이다.   
    그리고 timeout개념이 select와 동일한 방식으로 동작하기 때문에 timeout에 들어온 인자가 어떠냐에 따라 blocking이기도 하고 non-blocking이기도 하다. 따라서 epoll의 전체적인 개념모델은 select와 같다고 생각한다.
- <a href="https://d2.naver.com/helloworld/1469717" target="_blank">네이버 D2 - thread vs epoll</a>



출처: https://ozt88.tistory.com/21 [공부 모음]

<a href="https://github.com/nailbrainz/c10k_test/blob/master/src/c10k_select.c" target="_blank">c10k select example</a>

### controls
```cpp
fd_set readfds;
FD_ZERO(&readfds);
FD_SET(0, &readfds);  //readfds의 0번 비트를 1로
FD_SET(socketfd, &readfds); //readfds의 sockfd번 비트를 1로
FD_CLR(i, &reads); //readfds의 i 비트를 0으로
if(FD_ISSET(i, &cpy_reads)); //cpy_reads i 비트가 1인가?

sock_fd = accept(serv_fd, (struct sockaddr *)&client_addr, &add_struct_size);
FD_SET(sock_fd, &reads); //새로 할당하기
```


### epoll